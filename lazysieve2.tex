\documentclass[a4paper]{article}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{color}
\usepackage{hyperref}
\usepackage[utf8]{inputenc}
\usepackage{listingsutf8}
\usepackage{mathtools}
\usepackage{tikz-qtree}

\title{Lusta szita 2}
\author{}
\date{2018.9.2.}

\newcommand*{\bigOrdo}{\ensuremath{\mathcal{O}}}
\newcommand*{\Integers}{\ensuremath{\mathbb{Z}}}
\newcommand*{\NaturalsP}{\ensuremath{\mathbb{N}^+}}
\newcommand*{\NaturalsZ}{\ensuremath{\mathbb{N}_0}}
\newcommand*{\Trees}{\ensuremath{\mathcal{T}}}

\newcommand*{\fB}{\ensuremath{\operatorname{b}}}
\newcommand*{\fBC}[1]{\ensuremath{\operatorname{BK\left(#1\right)}}}
\newcommand*{\fFix}{\ensuremath{\operatorname{fix}}}
\newcommand*{\fInv}{\ensuremath{\operatorname{Inv}}}
\newcommand*{\fMove}{\ensuremath{\operatorname{move}}}

\newcommand*{\sAccumulated}[1]{\ensuremath{\operatorname{a}\left(#1\right)}}
\newcommand*{\sChildren}[1]{\ensuremath{\operatorname{c}\left(#1\right)}}
\newcommand*{\sDiff}[1]{\ensuremath{\operatorname{d}\left(#1\right)}}
\newcommand*{\sHeight}[1]{\ensuremath{\operatorname{h}\left(#1\right)}}
\newcommand*{\sLeft}[1]{\ensuremath{\operatorname{l}\left(#1\right)}}
\newcommand*{\sPosition}[1]{\ensuremath{\operatorname{q}\left(#1\right)}}
\newcommand*{\sPrime}[1]{\ensuremath{\operatorname{p}\left(#1\right)}}
\newcommand*{\sPrimes}[1]{\ensuremath{\operatorname{s}\left(#1\right)}}
\newcommand*{\sRight}[1]{\ensuremath{\operatorname{r}\left(#1\right)}}

\newcommand*{\vA}{\ensuremath{\operatorname{a}}}
\newcommand*{\vC}{\ensuremath{\operatorname{c}}}
\newcommand*{\vD}{\ensuremath{\operatorname{d}}}
\newcommand*{\vH}{\ensuremath{\operatorname{h}}}
\newcommand*{\vI}{\ensuremath{\operatorname{i}}}
\newcommand*{\vL}{\ensuremath{\operatorname{l}}}
\newcommand*{\vK}{\ensuremath{\operatorname{k}}}
\newcommand*{\vN}{\ensuremath{\operatorname{n}}}
\newcommand*{\vP}{\ensuremath{\operatorname{p}}}
\newcommand*{\vR}{\ensuremath{\operatorname{r}}}
\newcommand*{\vT}{\ensuremath{\operatorname{t}}}
\newcommand*{\vU}{\ensuremath{\operatorname{u}}}
\newcommand*{\vV}{\ensuremath{\operatorname{v}}}
\newcommand*{\vX}{\ensuremath{\operatorname{x}}}

\begin{document}

\maketitle

\tableofcontents

\section{Mertens tétele}

Mertens első és második tételének következménye, hogy

\begin{align*}
\sum_{\substack{\vP \leq \vN \\ \vP \text{prím}}} \frac{\ln{\vP}}{\vP} &\in \Theta(\log{\vN})
\\
\sum_{\substack{\vP \leq \vN \\ \vP \text{prím}}} \frac{1}{\vP} &\in \Theta(\log{\log{\vN}})
\end{align*}

\section{Ismételt összeadás}

A számok legyenek olyanok, hogy ezek a műveletek konstans idejűek
\begin{align*}
\vN = 0 \\
n / 2 \mapsto \Bigl\lfloor \frac{\vN}{2} \Bigr\rfloor \\
n \% 2 \mapsto \vN - 2 \Bigl\lfloor \frac{\vN}{2} \Bigr\rfloor \\
2 \vN + 0 \\
2 \vN + 1
\end{align*}

Ez láncolt listákkal könnyen teljesíthető. Az összeadást végezzük el így
\begin{align*}
b(x, y, z) &:= (x\%2)+(y\%2)+(z\%2) \\
r(x, e)
	&:= x, &\text{ha}\ (e/2)=0 \\
	&:= r(2x+(e \% 2), e/2), &\text{különben} \\
o(x, y, c, e)
	&:= r(y, e), &\text{ha}\ c=0 \land x=0 \\
	&:= r(x, e), &\text{ha}\ c=0 \land y=0 \\
	&:= o(x/2, y/2, d/2, 2e+(d \% 2)),
		&\text{különben, és}\ d=b(x, y, c)\\
a+b &:= o(a, b, 0, 1)
\end{align*}

Azaz tároljuk egy explicit veremben a részeredményt,
majd fejtsük vissza, ha már nincs több összeadandó bit. Pl.
\begin{align*}
2+3 = b10+b11 &= o(2, 3, 0, 1) = o(b10, b11, b0, b1) \\
	&= o(1, 1, 0, 3) = o(b1, b1, b0, b11) \\
	&= o(0, 0, 1, 6) = o(b0, b0, b1, b110) \\
	&= o(0, 0, 0, 13) = o(b0, b0, b0, b1101) \\
	&= r(0, 13) = r(b0, b1101) \\
	&= r(1, 6) = r(b1, b110) \\
	&= r(2, 3) = r(b10, b11) \\
	&= r(5, 1) = r(b101, b1) \\
	&= 5
\end{align*}

\begin{lstlisting}
Algoritmus I1(n):
x:=0
for i:=1 to n
  x:=x+1

Algoritmus I2(k, n):
x:=0
for i:=1 to n
  x:=x+k
\end{lstlisting}

Legyen $\fBC{\vX}$ az $\vX$ algoritmus bitkomplexitása.

\begin{align*}
\fBC{I1(\vN)} &\geq 2 \vN \\
\fBC{I1(\vN)}
	&\leq 2 \left( \vN + \frac{\vN}{2} + \frac{\vN}{4} + \frac{\vN}{8} + \ldots \right)
	\leq 4 \vN \\
\fBC{I1(\vN)} & \in \Theta(\vN) \\
\\
\vH & := \lfloor log_{2}{\vK} \rfloor + 1 \\
\fBC{I2(\vK, \vN)} &\geq 2 \vH \vN \\
\fBC{I2(\vK, \vN)}
	&\leq 2 ( h + 1 ) \left( \vN + \frac{\vN}{2} + \frac{\vN}{4} + \frac{\vN}{8} + \ldots \right)
	\leq 4 ( h + 1 ) \vN \\
\fBC{I2(\vK, \vN)} & \in \Theta(\vN \log{\vK})
\end{align*}

\section{Eratoszthenész szitája}
\begin{lstlisting}
Algoritmus E(n):
legyen 2..n semmi se lehuzva
for i:=2 to n
  if i nincs lehuzva
    i prim
    for j:=2*i to n step i
      legyen j lehuzva

\end{lstlisting}

Az egészrészek mágikus elhagyásával, és Mertens tételének felhasználásával

\begin{align*}
\fBC{E(\vN)} &= \Theta(\vN) + \Theta(\vN)
	+ \sum_{\substack{\vP \leq \vN\\\vP \text{prím}}}
		\fBC{I2(p, \Bigl\lfloor \frac{\vN}{\vP} \Bigr\rfloor)}
\\
\sum_{\substack{\vP \leq \vN\\\vP \text{prím}}}
	\fBC{I2(p, \Bigl\lfloor \frac{\vN}{\vP} \Bigr\rfloor)}
& \geq \sum_{\substack{\vP \leq \vN\\\vP \text{prím}}}
	\frac{2 \vN ( 1 + \log_{2}{\vP} )}{p}
= \frac{4n}{\ln{2}} \sum_{\substack{\vP \leq \vN\\\vP \text{prím}}}
	\frac{\ln{\vP}}{p}
\in \Theta(\vN \log{\vN})
\\
\sum_{\substack{\vP \leq \vN\\\vP \text{prím}}}
	\fBC{I2(p, \Bigl\lfloor \frac{\vN}{\vP} \Bigr\rfloor)}
& \leq \sum_{\substack{\vP \leq \vN\\\vP \text{prím}}}
	\frac{4 \vN (2+\log_{2}{\vP})}{p}
\leq \frac{12n}{\ln{2}} \sum_{\substack{\vP \leq \vN\\\vP \text{prím}}}
	\frac{\ln{\vP}}{p}
\in \Theta(\vN \log{\vN})
\\
\fBC{E(\vN)} & \in \Theta(\vN \log{\vN})
\end{align*}

\section{A természetes számok prefix fája}

Képzeljük el, hogy $\vN$-ig szitálnánk, és valahonnan már van egy binárs, teljes, kiegyensúlyozott
fa, aminek legalább $2\vN+1$ levele van. A fa élei legyenek 0-val címkézve, ha bal gyerekhez vezetnek, 1-gyel, ha jobb gyerekhez. Így ha $\vH$ a fa magassága, a levelek ábrázolhatják a
természetes számokat $0$-tól $2^h-1$-ig.

Ha még azt is elképzeljük, hogy minden csúcsban azt is eltároljuk, hogy csúcsból a gyökérig vezető úton van-e még 1-es bit, akkor bármelyik csúcsból a gyökérbe vezető út teljesíti az ismételt összeadásnál megkövetelt feltételeket.

Az összeadást lehet módosítani úgy, hogy az egyik argumentuma mindig a fa egyik levele,
és az eredmény is a fa levele lesz.

Pl. 2+3 újra:

\Tree
[.0-15
	\edge node[auto=right,pos=.6] {$0$};
	[.0-7
		\edge[draw=red] node[auto=right,pos=.6] {$0$};
		[.0-3
			\edge node[auto=right,pos=.6] {$0$};
			[.0-1
				\edge node[auto=right,pos=.6] {$0$};
				[.0 ]
				\edge node[auto=left,pos=.6] {$1$};
				[.1 ] ]
			\edge[draw=red] node[auto=left,pos=.6] {$1$};
			[.2-3
				\edge[draw=red] node[auto=right,pos=.6] {$0$};
				[.2 ]
				\edge node[auto=left,pos=.6] {$1$};
				[.3 ] ] ]
		\edge[draw=red] node[auto=left,pos=.6] {$1$};
		[.4-7
			\edge[draw=red] node[auto=right,pos=.6] {$0$};
			[.4-5
				\edge node[auto=right,pos=.6] {$0$};
				[.4 ]
				\edge[draw=red] node[auto=left,pos=.6] {$1$};
				[.5 ] ]
			\edge node[auto=left,pos=.6] {$1$};
			[.6-7
				\edge node[auto=right,pos=.6] {$0$};
				[.6 ]
				\edge node[auto=left,pos=.6] {$1$};
				[.7 ] ] ] ]
	\edge node[auto=left,pos=.6] {$1$};
	[.8-15
		\edge node[auto=right,pos=.6] {$0$};
		[.8-11
			\edge node[auto=right,pos=.6] {$0$};
			[.8-9
				\edge node[auto=right,pos=.6] {$0$};
				[.8 ]
				\edge node[auto=left,pos=.6] {$1$};
				[.9 ] ]
			\edge node[auto=left,pos=.6] {$1$};
			[.10-11
				\edge node[auto=right,pos=.6] {$0$};
				[.10 ]
				\edge node[auto=left,pos=.6] {$1$};
				[.11 ] ] ]
		\edge node[auto=left,pos=.6] {$1$};
		[.12-15
			\edge node[auto=right,pos=.6] {$0$};
			[.12-13
				\edge node[auto=right,pos=.6] {$0$};
				[.12 ]
				\edge node[auto=left,pos=.6] {$1$};
				[.13 ] ]
			\edge node[auto=left,pos=.6] {$1$};
			[.14-15
				\edge node[auto=right,pos=.6] {$0$};
				[.14 ]
				\edge node[auto=left,pos=.6] {$1$};
				[.15 ] ] ] ] ]

\section{Eratoszthenész szitája fával}

Eratoszthenész szitáját így is implementálhatjuk

\begin{lstlisting}
Algoritmus E2(n):
for i:=2 to n
  if letezik p i-hez rendelve
    for minden p i-hez rendelve
      rendeljuk p-t (i+p)-hez
  else
    i prim
    rendeljuk i-t 2i-hez
\end{lstlisting}

Ha számokhoz konstans időben rendelhetünk prímeket, és olvashatjuk azokat ki,
akkor
\begin{align*}
\fBC{E2(n)}=\fBC{E(n)}
\end{align*}

Legyen $\vN$ a fa egy levele, $\vK$ egy listával ábrázolt szám, és $CS(\vN, \vK)$
azon csúcsok halmaza a fában, amiket az $n+k$ elvégzése érint.
Legyen
\begin{align*}
CS^{*}(\vN, \vK) = CS(\vN, 1) \cup CS(\vN+1, 1) \cup \ldots \cup CS(\vN+\vK-1, 1)
\end{align*}

Ekkor
\begin{align*}
CS(\vN, \vK) \subseteq CS^{*}(\vN, \vK)
\end{align*}

Ha az E2 algoritmust úgy implementáljuk, hogy egy $i+p$-hez
rendelésnél nem végzi el az összeg teljes kiszímítását,
hanem egy közbülső csúcshoz rendeli az addig elvégzett részleges számítást,
akkor az $i:=i+1$ számítások egyike érinti a félbehagyott számítást,
és hamarabb érinti, mint hogy $i+p$ -ig érne.

\section{Lustán elképzelt fa}

Eddig azt fejtegettük, hogy ha el tudunk képzelni egy elég nagy fát elég gyors műveletekkel,
akkor Eratoszthenész szitáját implementálhatjuk úgy, hogy a lehúzásokkal sorban haladhatunk,
és az aszimptotikus futási ideje megegyezik a szokásos, tömbben össze-vissza
lehúzásos implementációval.

A előző fejezet részleges számításainál nem nyilatkoztunk arról, hogy melyik csúcsban érdemes abbahagyni az összeadásokat, és hogy mikor érdemes folytatni, és meddig érdemes folytatni.

Minden összeadás útja a fában úgy néz ki, hogy valahány lépést halad a csúcs felé,
egy csúcsban, ahol a bal gyerek felől érkezik, nem a szülő felé folytatja a leszámolást,
hanem a jobb gyerek felé folytatja az utat, majd az eredmény függvényében a gyerekek felé
haladva kiválaszt egy levelet. Ez a forduló mindig rajta van az aktuális pozíciót
a gyökérrel összekötő úton.

Tároljuk a részleges számításokat a forduló utáni közvetlen, jobb gyerekben.
A félbehagyott számításokat mindig akkor folytassunk, amikor az aktuális pozíció eggyel növelésének elvégzésénél egy csúcsba a szülője felöl érkezünk, és olyankor egyetlen lépést végezzünk el a félbehagyott számításokban, azaz a fában egyetlen szinttel mozgassuk lejjebb.
Ilyenkor a fában felfele haladva nem is fogunk találkozni részleges számítással.

Az is megfigyelhető hogy az új aktuális pozícióban azok a prímek szitálnak,
amik az $i:=i+1$ forduló jobb gyerekében lettek félbehagyva, és a részeredmény minden bitje 0,
azaz a legbalabb levelébe tartoznak, ami éppen az új aktuális pozíció
a szitatáblában.

Ha így járunk el, akkor a nagy elképzelt fa helyett elég egy láncolt listát tárolnunk,
a lista hossza arányos a fa magasságával, és a lista minden elemében el kell tárolni az ahhoz a magassághoz tartozó részleges számítások vödrét, és egy bitet,
amiben az aktuális pozíció számjegyei vannak.

Nézzük kicsit részletesebben az algoritmust.

Ha a fában az aktuális pozíció $i$, és $p$-t $i+p$-hez akarjuk rendelni,
akkor az összeadás részleges elvégzésével keressük meg az első csúcsot, ami nincs rajta
az $i \rightarrow \text{győkér}$ úton, és ahhoz kell rendelni a részeredményt.

Ha szitálás közben az $i$ az új aktuális pozíció a szitattáblában,
akkor az $(i-1)+1$ részleges elvégzésével keressük meg, hogy melyik az első csúcs,
ami nincs rajta az $(i-1) \rightarrow \text{gyökér}$ úton. Ilyenkor ezalatt a szint alatt
nincs félbehagyott számítás. Viszgáljuk meg az összes részeredményt, amit ebben a csúcsban találunk.
A részeredmény legelső bitjét vizsgálva, amíg az 0, addig a fában haladjunk a bal gyerek felé,
majd ha még nem üres a részeredmény, akkor egyet a jobb gyerek felé.

Amikor végeztünk az összes talált részszámítással, akkor nézzük meg, mi került a legbalabb gyerekbe, azaz az $i$ aktuális pozíció levelébe. Ha üres, akkor $i$ prím, és fel kell venni a fába $2i$ pozícióba.
Ha nem üres, akkor minden talált $p$ prímet fel kell venni a fába $i+p$ pozícióba.

Igazából amikor az $i+x$ fordulóját keressük, arra vagyunk kiváncsiak, hogy melyik a legnagyobb helyiértékű bit, ahol $i$ és $i+x$ különbözik, de ha ezt a fa gyökere felől néznénk, akkor a műveletigényt a fa magasságával lehetne csak becsülni, még alulról összeadva a műveletigény
becsülhető $\log{x}$-szel.

Példaként szitáljunk 2-től 15-ig a már lerajzolt fában.
A példában $(p: i)$ jelentse azt, hogy a $p$ prímet az $i$ pozícióba kéne tenni.
Vegyük sorra, hogy mi lenne ebben fát ábrázoló listában,
ahogy az aktuális pozíció 2-től 15-ig lép.
A piros számokjegyek a legmagasabb változott helyiértékek.

$i=2$, prím

\begin{tabular}{l|l|l}
\text{lista-index} & számjegy & \text{prímek utána} \\
2 & 0 & (2: 4+0) \\
1 & {\color{red}1} & \\
0 & 0 & \\
\end{tabular}

$i=3$, prím

\begin{tabular}{l|l|l}
\text{lista-index} & számjegy & \text{prímek utána} \\
2 & 0 & (2: 4+0), (3: 4+2) \\
1 & 1 & \\
0 & {\color{red}1} & \\
\end{tabular}

$i=4$

\begin{tabular}{l|l|l}
\text{lista-index} & számjegy & \text{prímek utána} \\
2 & {\color{red}1} & \\
1 & 0 & (3: 6+0), (2: 6+0) \\
0 & 0 & \\
\end{tabular}

$i=5$, prím

\begin{tabular}{l|l|l}
\text{lista-index} & számjegy & \text{prímek utána} \\
3 & 0 & (5: 8+2) \\
2 & 1 & \\
1 & 0 & (3: 6+0), (2: 6+0) \\
0 & {\color{red}1} & \\
\end{tabular}

$i=6$

\begin{tabular}{l|l|l}
\text{lista-index} & számjegy & \text{prímek utána} \\
3 & 0 & (5: 8+2), (3: 8+1), (2: 8+0) \\
2 & 1 & \\
1 & {\color{red}1} & \\
0 & 0 & \\
\end{tabular}

$i=7$ prím

\begin{tabular}{l|l|l}
\text{lista-index} & számjegy & \text{prímek utána} \\
3 & 0 & (5: 8+2), (3: 8+1), (2: 8+0), (7: 8+6) \\
2 & 1 & \\
1 & 1 & \\
0 & {\color{red}1} & \\
\end{tabular}

$i=8$

\begin{tabular}{l|l|l}
\text{lista-index} & számjegy & \text{prímek utána} \\
3 & {\color{red}1} & \\
2 & 0 & (7: 12+2) \\
1 & 0 & (5: 10+0), (2: 10+0) \\
0 & 0 & (3: 9+0) \\
\end{tabular}

$i=9$

\begin{tabular}{l|l|l}
\text{lista-index} & számjegy & \text{prímek utána} \\
3 & 1 & \\
2 & 0 & (7: 12+2), (3: 12+0) \\
1 & 0 & (5: 10+0), (2: 10+0) \\
0 & {\color{red}1} & \\
\end{tabular}

$i=10$

\begin{tabular}{l|l|l}
\text{lista-index} & számjegy & \text{prímek utána} \\
3 & 1 & \\
2 & 0 & (7: 12+2), (3: 12+0), (5: 12+3), (2: 12+0) \\
1 & {\color{red}1} & \\
0 & 0 & \\
\end{tabular}

$i=11$ prím

\begin{tabular}{l|l|l}
\text{lista-index} & számjegy & \text{prímek utána} \\
4 & 1 & (11: 16+6) \\
3 & 1 & \\
2 & 0 & (7: 12+2), (3: 12+0), (5: 12+3), (2: 12+0) \\
1 & 1 & \\
0 & {\color{red}1} & \\
\end{tabular}

$i=12$

\begin{tabular}{l|l|l}
\text{lista-index} & számjegy & \text{prímek utána} \\
4 & 1 & (11: 16+6) \\
3 & 1 & \\
2 & {\color{red}1} & \\
1 & 0 & (2: 14+0), (3: 14+1), (5: 14+1), (7: 14+0) \\
0 & 0 & \\
\end{tabular}

$i=13$ prím

\begin{tabular}{l|l|l}
\text{lista-index} & számjegy & \text{prímek utána} \\
4 & 1 & (11: 16+6), (13: 16+10) \\
3 & 1 & \\
2 & 1 & \\
1 & 0 & (2: 14+0), (3: 14+1), (5: 14+1), (7: 14+0) \\
0 & {\color{red}1} & \\
\end{tabular}

$i=14$

\begin{tabular}{l|l|l}
\text{lista-index} & számjegy & \text{prímek utána} \\
4 & 1 & (7: 16+5), (2: 16+0), (11: 16+6), (13: 16+10) \\
3 & 1 & \\
2 & 1 & \\
1 & {\color{red}1} & \\
0 & 0 & (3: 15+0), (5: 15+0) \\
\end{tabular}

$i=15$

\begin{tabular}{l|l|l}
\text{lista-index} & számjegy & \text{prímek utána} \\
4 & 1 & (3: 16+2), (5: 16+4), (7: 16+5), \\
  &   & (2: 16+0), (11: 16+6), (13: 16+10) \\
3 & 1 & \\
2 & 1 & \\
1 & 1 & \\
0 & {\color{red}1} & \\
\end{tabular}

\section{Egyebek}

Előnyök:
\begin{itemize}
\item akár s\&m funkcionálisan is implementálható bitekkel és láncolt listákkal
\item fixnum implementációban a gyökérbe vezető lista lehet egy tömb,
	és a forduló csúcs meghatározható xor és bit-scan-right assembly utasítsokkal
\item ha a fa bővíthető, nem kell eldönteni előre, hogy meddig szitálunk
\item aszimptotikusan optimális
\item cache oblivious, talán
\item könnyen implementálható fixnum
\item talán általánosítható egy cache oblivious queue-ra,
	ahol a betett elem nagyságától függ mindenféle idő, nem az elemek számától
\end{itemize}

Hátrányok:
\begin{itemize}
\item a memóriaigénye $\Theta(\vN)$
\item a prímek semmilyen tulajdonságát nem használja ki
\item macerás implementálni bignum
\item macerás formalizálni
\item nem tudom, hogy kéne formálisan bizonyítani a helyességét
\item nem tudom, hogy kéne formálisan bizonyítani a futási időt
\item nem tudom, hogy kéne formálisan bizonyítani, hogy cache oblivious
\end{itemize}

Nézegethető dolgok:
\begin{itemize}
\item fixnum ennyire könnyű szó szerint implementálva \\
	\url{https://github.com/zooflavor/lazysieve/blob/master/ls2.c}
\item csináltam egy függvényillesztőt \\
	\url{http://arrostia.web.elte.hu/lazysieve/ffit/ffit.html} \\
	ennek a helyességével vannak gondok, a polinomiális regresszióra is csak
	ráfogtuk nummod2-n, hogy helyes \\
	a pixelek szemre illeszkednek és színesek...
\item összehasonlítottam a futási idejét a legegyszerűbb szitával,
	és csináltam egy grafikont belőle \\
	\url{http://arrostia.web.elte.hu/lazysieve/speed/} \\
	a csv file-okkal ki lehet próbálni az illesztőt \\
	az oszlopok
	\begin{itemize}
	\item n-ig szitálva, a többi oszlop nanosec.
	\item array: egy nagy tömbben a szokásos szitálás, algoritmus E
	\item ls2-1: a fixnum implementáció, a szitatáblában egyesével halad
	\item ls2-2: mint az ls2-1, de a szitatáblátban rövidebb szakaszonként halad,
		a fa-listába csak azokat a prímeket teszi, amik nagyobbak, mint a szakasz hossza,
		a kis prímeket egy nagy tömbben gyűjti, és csak mindig végigloop-ol rajtuk
	\item ls2-3: mint az ls2-2, de a nagy prímeken használja a 2-3-5 kereket
	\end{itemize}
\item megszámoltam, hogy hipotetikus időben mit segít egy gyors cache \\
	 \url{http://arrostia.web.elte.hu/lazysieve/cache/} \\
	 a cache igyekszik a lista kisebb indexeit tárolni, amik gyakarabban sorra kerülnek \\
	 a hipotetikus idő 1000ns ha sikerül a cache-be írni, vagy onnan olvasni, és 1000000ns,
	 ha csak a lassú tárba sikerült írni, vagy onnan kell olvasni. \\
	az oszlopok
	\begin{itemize}
	\item n-ig szitálva, a többi oszlop nanosec.
	\item a: ez igazi időben van, a hipotetikus számolás kikapcsolva
	\item cx: x prím nagyságú a cache
	\end{itemize}
	említésre méltó, hogy a cache nélküli hipotetikus idő mintára remekül illeszthető
	az elvárt $n \ln{n}$
\end{itemize}

\end{document}

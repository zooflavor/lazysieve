\chapter{Fejlesztői dokumentáció}

A fejlesztői dokumentáció áttekintést ad a megvalósításban felhasznált módszerekről, a fejlesztés során hozott döntésekről, valamint a forráskód felosztásáról, és legfontosabb részeiről.

Az adatbázis szerkezetének leírását követően a fejezet végigveszi a megoldást alkotó három programot.
Az \texttt{init} és a \texttt{generator} program egy feladatot old meg, a prímek listájának előállítását.
A \texttt{gui} program leírása tartalmazza a felhasznált adatszerkezeteket, a statisztikák elkészítésének részleteit, az elemi függvények illesztését a legkisebb négyzetek módszerével, és a grafikonok megjelenítését.

A megvalósított eratoszthenészi szitákat külön szakasz írja le.
Ez a saját ötlet alapján készült edénysor részletes leírását is tartalmazza.

A programok tesztelésénél külön feladat volt a legkisebb négyzetek módszerénél használt numerikus algoritmusok kiválasztása.

A program komponenseinek ábrája az \pageref{komponensek} oldalon látható.

\section{Az adatbázis}

A program adatbázisa egy egyszerű könyvtár, amin keresztül a különböző programrészek kommunikálnak.
Az adatbázis két fajta fájlt tárol, a szitált szegmenseket, azaz a szitatábla bitvektorait, és a szegmensek összesítéseit.
Mindkettő a szegmens első számával van azonosítva, a szegmens hossza mindig $2^{30}$ szám, és az $n \in \mathbb{N}_0$ megengedett kezdő szám, ha $n < 2^{64}-2^{34}$ és $n \equiv 1 \pmod{2^{30}}$.
Minden szegmens egy külön fájl az adatbázis könyvtárában.
Az összes szegmensstatisztika egy fájlban van.

Az \texttt{init} program az első 4 szegmensfájlt írja.
A \texttt{generator} az első 4 szegmensfájlt olvassa, és az összes többi szegmensfájlt írja.
A \texttt{gui} az összes szegmensfájlt olvassa, és egyiket se írja, és szegmensstatisztika fájlt csak a \texttt{gui} használja.

Egy szegmensfájlok neve \texttt{primes.} előtaggal kell kezdődjön, és pontosan 16 hexadecimális számjegy kell kövesse, ami a szegmens által leírt első szám.
A fájl bináris, a legkisebb helyiértékű bájt elöl, azaz little endian sorrendben.
A tartalma:
\begin{itemize}
\item a szegmens elejével kezdve $2^{29}$ egymást követő páratlan szám bitvektora.
	
Ez $2^{26}$ byte, legkisebb helyiértékű byte elöl sorrendben, minden bit egy páratlan szám összetettségét írja le.
Ha a bit $1$, akkor a szám összetett, ha $0$, akkor a szám prím.
Ha $s$ a szegmens intervallumának kezdete, akkor az $0.$ bájt $0.$ bitje $s$-t írja le, a $0.$ bájt $1.$ bitje $s+2$-t, a $i.$ bájt $j.$ bitje $s+16i+2j$-t.
	
\item a szegmens kezdete, 8 bájt, egész
\item a szegmens szitálására való felkészülés ideje, 8 bájt, egész, nanoszekundumokban
\item a szegmens szitálásának ideje, 8 bájt, egész, nanoszekundumokban
\end{itemize}

Ahhoz, hogy az \texttt{init} és a \texttt{generator} program bármikor leállítható legyen, a szegmenst először a \texttt{tmp.tmp} ideiglenes fájlba írja, és ha ez hiba nélkül megtörtént, akkor az ideglenes fájlt átnevezi a megfelelő névre.
Mivel az ideiglenes fájl ugyanabba a könyvtárba kerül, mint ahova a szegmensfájl is, így feltételezhető, hogy helyi meghajtón az átnevezés már atomi művelet.

A szegmensstatisztikák az \texttt{aggregates} fájlban vannak.
A szegmensek a fájlban a kezdőszámok sorrendjében követik egymást, egy szegmensnek legfeljebb egy statisztikája lehet.
A fájl bináris, a legnagyobb helyiértékű bájt elöl, azaz big endian sorrendű. A fájl fejléce:
\begin{itemize}
\item formátum azonosító: 0xd1d1b0b0, 4 bájt
\item verziószám: 1, 4 bájt.
\end{itemize}
Ezután minden statisztika egy változó méretű blokkban van tárolva, a fájl végéig.
Minden block két részből áll, az első 4 bájt a második rész mérete bájtokban.
Ez a második rész a szegmensstatisztika.
A statisztika gzip formátumban tömörített, kitömörítve bináris adat, aminek a formátuma:
\begin{itemize}
\item a szegmens összesítésére fordított idő, 8 bájt, nanoszekundumokban
\item a szita inicializálásának ideje a szegmens szitálása előtt, 8 bájt, nanoszekundumokban
\item az összesített szegmensfájl utolsó módosításának ideje, 8 bájt, milliszekundumokban, 1970.1.1. 00:00:00-tól
\item a szegmensben található legnagyobb prím, 8 bájt
\item a szegmensben található legkisebb prím, 8 bájt
\item a $12\mathbb{Z}+11$ alakú prímek száma a szegmensben, 8 bájt
\item a $4\mathbb{Z}+1$ alakú prímek száma a szegmensben, 8 bájt
\item a $4\mathbb{Z}+3$ alakú prímek száma a szegmensben, 8 bájt
\item a $6\mathbb{Z}+1$ alakú prímek száma a szegmensben, 8 bájt
\item a szegmensben előforduló prímhézagok száma, 4 bájt. ahány prímhézag előfordult, annyiszor ismétlődik a következő három mező
\begin{itemize}
\item a prímhézag nagysága, 8 bájt
\item a prímhézag előfordulásainak száma, 8 bájt
\item a prímhézag első előfordulása, 8 bájt
\end{itemize}
\item a szegmens sorszáma, 8 bájt
\item a szegmens vége, 8 bájt
\item a szegmens kezdete, 8 bájt
\item a szegmens szitálására fordított idő, 8 bájt, nanoszekundumokban.
\end{itemize}

Az összesítésfájl írása a szegmensfájl írásához hasonló.
A program az adatokat először az \texttt{aggregates.tmp} ideiglenes fájlba írja, majd megvárja, hogy a fájl tartalma a háttértárolóra kerüljön.
Utána az ideiglenes fájlt átnevezi \texttt{aggregates}-re.
Az ideiglenes fájl kiírásának megvárásával a összesítésfájl váratlan számítógép leállás esetén is visszaállítható.

A fájl formátuma és az új fájl kiírásának algoritmusa lehetővé teszi, hogy a statisztikafájlt egyszerre lehessen sorban felolvasni, és az új eredményt sorban kiírni, úgy, hogy egyszerre csak egy statisztikát kelljen a memóriában tartani.

Az adatbázis nincs védve a párhuzamos írásoktól, és az összesítőfájl egyszerű sorban feldolgozhatósága feltételezi, hogy egy fájl kevés szegmensstatisztikát fog tartalmazni, legfeljebb kb. $10^6$ szegmensét.

\section{Init és generator}

Az \texttt{init} és a \texttt{generator} forráskódja a tarball \texttt{generator} könyvtárában van.

A \texttt{generator} egy optimalizált szita, $2^{32}$-től $2^{64}-2^{34}$-ig képes szitálni.
Az utolsó $2^{34}$ szám kihagyása egyszerű könnyítés, így a programban az éppen szitált szám változója sosem csordul túl.

A két program egymáshoz nagyon hasonló feladatot lát el, hasonló megoldásokkal.
Mindkettő $2^{30}$ hosszú intervallumokat szitál, és az eredményt szegmensfájlokba írja.
Mindkettő Eratoszthenész szitáját használja.
Mindkét program ezt az egyetlen feladatot oldja meg, és szkriptekkel automatizált, kötegelt futtatásra van tervezve.

\subsection{Közös rész}

A két program közös kódja a \texttt{common.h} fájl.
Ez a fájl tartalmazza a konstansokat, és az eljárásokat, amik megkönnyítik a POSIX hívások használatát.
A legtöbb ilyen könnyítés a hibák kezelésének elfedése, ami a kötegelt futtatáshoz illeszkedően
a hiba kijelzése utáni azonnali programleállás.
Az I/O műveleteket könnyítik meg a \texttt{readFully()}/\texttt{writeFully()} eljárások.

A sziták belső, kis szegmensmérete a \texttt{SEGMENT\_SMALL\_SIZE\_BITS\_LOG2} konstanssal szabályozható, és a \texttt{measure-generator} szkript kimenete alapján egy adott géphez igazítható.

A szegmensfájlok olvasására és írásara a \texttt{readSegment()} és \texttt{writeSegment()} függvények szolgálnak.

\subsection{Init}

Az \texttt{init} program előállítja az első 4 szegmens fájlt, azaz $2^{32}$-ig az összes prímet megkeresi.
Ezekkel a prímekkel a többi részprogram már a $[2^{32}, 2^{64})$ tartomány tetszőleges részén tud szitálni.

A szita egy egyszerű szegmentált eratoszthenészi szita.
A $2^{30}$ hosszú szegmenseket több kisebb, egyenlő szegmensre osztja, és ezeket a kis szegmenseket
egymás után szitálja a prímek listáján végigmenve.
A prímek mellett a következő szitálás helyét is eltárolja, így nem kell minden szegmens szitálásának elején minden prímhez osztással meghatározni, hogy melyik a legkisebb szám a szegmensben, amit az oszt.
Így egy kis szegmensben egy prímre a következő algoritmus fut le.
Ez az algoritmus visszatérő minta a szegmentált szitákban.

\begin{algorithmic}[1]
\State $p$: a prím
\State $q$: a következő szám, amit $p$ oszt
\State $e$: a szegmens vége
\While{$q$ < $e$}
	\State \Call{Megjelöl}{$q$}
	\State $q \gets q + 2p$
\EndWhile
\end{algorithmic}

Az \texttt{init} szitájának inicializálásához a prímek listáját elő kell előállítani $2^{16}$-ig, ezt a program próbaosztással végzi el.

\subsection{Generator}

A \texttt{generator} fő részei hasonlóak az \texttt{init}-hez.
Indulása után az első 4 szegmensfájl alapján $2^{32}$-ig minden prímhez osztással meghatározza, hogy melyik a legkisebb szám, amit oszt, és legalább akkora, mint a szitálandó szegmens kezdete.
A prímeket tároló adatstruktúra szitálás közben nem érzékeny azokra az elemekre, amik az éppen szitált szegmensnél nagyobb helyeken szitálnak, így a \texttt{generator} az összes prímet eltárolja $2^{32}$-ig, nem csak a szitálandó tartomány végének négyzetgyökéig.

A prímek listájának inicializálása után a nagy szegmenseket az \texttt{init}-hez hasonlóan kisebbekre osztja, és ezeket sorban szitálja a prímek listája alapján.

A prímek listája a \texttt{generator}-ban több külön adatszerkezet összessége.
A prímeket az inicializálásakor 3 részre osztja a nagyságuk szerint.
A $64$-nél kisebb prímeket $64$-bit széles bitmintákban tárolja, és ezekkel a mintákkal $64$-bitesével szitálja végig a kis szegmenseket a bitenkénti vagy művelettel.
A 3 és a 11, valamint az 5 és a 7 szorzata kisebb, mint 64, ezeket a párokat egyetlen $64$ bites mintába fejti ki, ezeknek a mintáknak a periódusa 33, és 35.
A többi prím mintájának periódusa a legnagyobb olyan szám, ami 64-nél kisebb, és a prím osztja.

A prímek, amik $64$-nél nagyobbak, de a kis szegmensek hosszánál kisebbek, azaz minden kis szegmensben szitálnak, az \texttt{init}-hez hasonlóan egy egyszerű tömbbe kerülnek, és ugyanúgy szitál ezekkel a program, mint az \texttt{init}-ben.

A kis szegmensek hosszánál nagyobb prímek egy kis szegmensben legfeljebb egyszer szitálnak, és van olyan szegmens, ahol egyszer sem.
A \texttt{generator} ezeket a prímeket egy prioritásos sorban tárolja, amiben az elemek sorrendjét a következő szegmens száma határozza meg, amiben az a prím szitálni fog.
A szegmensen belüli sorrendet a sor nem veszi figyelembe.
A kis szegmensekben legfeljebb egyszer szitáló prímeknek nem csak a páros többszöröseit ugorja át a szita, hanem a 3-mal és 5-tel osztható többszöröseit is kihagyja.
Ezeket a többszörösöket a bitmintával szitáló kis prímek jelölik meg.

Az edénysor algoritmusának részletes leírására a \pageref{sec:szitak} oldalon a ''Sziták'' szakaszban kerül sor.
Az ott leírt távolság függvényt implementálja a \texttt{bucketIndex()} függvény a forráskódban.
A távolságfüggvény által használt számrendszert a \texttt{BUCKET\_BITS} konstans szabályozza,
a számrendszer alapja $2^{\texttt{BUCKET\_BITS}}$.
A sorhoz tartozó edények listája a \texttt{buckets} tömb, ennek minden eleme egy láncolt lista, ahol a listaelemek fix méretű edények.

A program futása alatt a sor elemeinek száma nem változik, de az elemek az edények között mozognak.
A sor legkisebb elemeinek, azaz az aktuális szegmensben szitáló prímek megkereséséhez a lista egyik edényének minden elemét megvizsgálja.
Ha egy elem az aktuális szegmensben nem szitál, akkor az elemet a sorba visszahelyezi, a távolság függvény szerint már közelebbi edénybe.
Ha az elem szitál az aktuális szegmensben, akkor elvégzi a szitálást, és az elemet visszateszi a sorba, azon pozíció szerint, ahol a prím legközelebb szitálni fog.

A 2, 3, és 5 többszöröseinek hatékony kihagyásához a prioritásos sor elemeiben a pozíció mellett el van tárolva, hogy az a pozíció melyik modulo $30$ maradékosztály eleme.
A nyolc szóba jöhető lehetőség közül a \texttt{PrimePosition.prime} mező felső 3 bitje választ.
Ezt a 3 bit információt biztonsággal lehet itt tárolni, a 64 bit széles változóban a feladat határai miatt mindig csak az alsó 32 tartalmaz értékes számjegyet.
Ez a 2-3-5 kerék alapú gyorsítás csak a prioritásos sorban tárolt prímekre van alkalmazva.

\section{Gui}

A program Java-ban írt része tartalmazza az összes többi funkció megvalósítását: a szegmensfájlok feldolgozását, a különböző szitákat, és a minták megjelenítését.
Ezeknek a funkcióknak a többsége nem interaktív, a felhasználó a paraméterek megadása után a végrehajtást már nem tudja befolyásolni.

A forráskód ennek megfelelően három egymásra épülő szintre osztható:
\begin{itemize}
\item A legalsó szint a program adatszerkezeteit, algoritmusait, és fájlformátumait írja le. 
\item Erre építenek a felhasználói műveletek megvalósításai.
Mindegyik művelethez tartozik egy eljárásként megvalósított belépési pont.
\item A programkód legfelső szintje ezeket teszi a felhasználó számára meghívhatóvá, parancssorból és grafikusan is.
\end{itemize}

A grafikonmegjelenítés az egyetlen ténylegesen interaktív feladat, ennek megoldása a modell-nézet-vezérlő felosztást alkalmazza.

\subsection{gui.util}

A csomag néhány közismert algoritmust és adatszerkezetet tartalmaz, valamint az ezekhez szükséges funkcionális interfészek definícióit.
A legtöbbnek létezik könnyen használható sztenderd könyvtári megvalósítása, de ezek referenciatípusokat használnak.

A primitív és referencia típusú értékek közötti rengeteg konverzió három problémát okoz.
Feleslegesen növeli a futási időt, miközben egyetlen számítógépen eleve reménytelenül hosszú feladat $2^{64}$-ig szitálni.
Ezen túl megnöveli a program memóriaigényét.
$2^{32}$-ig kb. $\num{2e8}$ prím van, ha egy szita csak a prím-pozíció párokat egy egyszerű tömbben tárolná, prímenként 4 bájton, pozíciónként 8 bájton, akkor ez a tömb kb. $2,4$Gb memóriát foglalna el.
A program a primitív típusokon alapuló konténerekkel képes $3,5$Gb memória használatával futni.
A harmadik probléma az, hogy primitív érték objektummá alakítása szinte mindig új objektum létrehozásával jár, ami legtöbbször egy objektum elérhetetlenségéhez is vezet.
A szemétgyűjtő ezzel járó folyamatos háttérmunkája nem csak feleslegesen növeli a futási időt, hanem kiszámíthatatlanságával megnöveli a sziták mért futási idejének zaját is.

A \texttt{PrimitiveList} osztály és leszármazottai az \texttt{ArrayList} mintájára szükség szerint növekvő vektorok. Konkrét megvalósítások a \texttt{double}, \texttt{int}, és \texttt{long} primitív típusokra vannak.

A \texttt{BinarySearch} és a \texttt{QuickSort} a bináris keresés és a gyorsrendezés algoritmusát valósítják meg absztrakt módon elért tömb felett.
Az elemeket közvetlenül sosem érik el, az összehasonlításokat és a cseréket interfészeken keresztül végzik index alapján.

A \texttt{BinaryMinHeap} egy bináris kupacot megvalósító absztrakt konténerosztály, az elemek típusától függő műveleteket absztrakt metódusként határozza meg.
A műveletek felteszik, hogy az elemek indexelhetőek, mint egy tömbben.
A kupac egy elsőbbségi sor, a sor eleje az absztrakt rendezés szerinti legkisebb elem.

\subsection{gui.math}

Az \texttt{UnsignedLong} osztály a Java \texttt{long} típus előjel nélküli műveleteit valósítja meg.
A Java a 8-as verziótól támogatja a primitív egész típusok előjel nélküli összehasonlítását és osztását, ez az osztály ezekre építve ad néhány segédeljárást.

A pszeudoprím-teszthez a maradékos hatványozás, Java támogatás hiányában, a kitevő bitjei alapján az ismételt szorzást és négyzetre emelést használja, míg a szorzás ehhez hasonlóan összeadást és kétszerezést.
Ezeknek az algoritmusoknak a futási ideje egy-egy szám esetén elfogadható, de intervallumok szitálására nem alkalmas.

\subsubsection{Közelítés}

A \texttt{gui.math} csomag a legkisebb négyzetek módszerének implementációját, és annak segédosztályait is tartalmazza.

A \texttt{Sum} \texttt{double} típusú értékek véges összegeit számolja ki.
A \texttt{double} véges pontosságának következménye, hogy nem minden szám reprezentálható \texttt{double} értékként, és többtagú összeg eredménye függhet a tagok összeadásának sorrendjétől, azaz az összeadások sorrendje befolyásolhatja az eredmény hibáját.

A \texttt{Sum} három stratégiát ad az összeadások sorrendjéből származó hiba minimalizálására.
A program használata közben a felhasználó ezek közül nem tud választani, a tesztek alapján legstabilabbnak ítélt elsőbbségi soron alapuló összegzést használja a közelítés.

A legegyszerűbb \texttt{Sum.Simple} egyetlen változót használva a tagokat felsorolásuk sorrendjében adja össze.

A bináris kupacot használó \texttt{Sum.Priority} a tagokat az elsőbbségi sorban gyűjti, majd a végső összeg kiszámításához a sorból, amíg lehet, ismételten kiveszi a két legkisebb abszolút értékű elemet, azokat összeadja, és az eredményt a sorba visszahelyezi.
A végeredmény a sorban maradó érték lesz.

A \texttt{Sum.Array} nagyságrend szerinti részösszegeket tart nyilván, új tagot a nagyságrendjéhez tartozó részösszeghez adja hozzá.
A nagyságrend a double érték IEEE 754 szabvány szerinti reprezentációjának kitevője. Ebben a reprezentációban a kitevő $11$ bit hosszú, a\texttt{ Sum.Array} így mindig $2048$ részösszeget tárol.

A \texttt{RealFunction} interfész valóshoz valóst rendelő függvények reprezentációi, ezek lehetnek a közelítés elemi függvényei.
Egy függvény a helyettesítési értékein kívül az értelmezési tartományáról is információt kell adjon.
A grafikonmegjelenítő az $x$-tengely egy pixel által lefedett intervallumán akkor jelenít meg értéket, ha az intervallum egésze az értelmezési tartomány része.

A \texttt{Functions} osztály a beépített elemi függvényeket tartalmazza.
Már létező függvények lineáris kombinációját a \texttt{LinearCombinationFunction} osztállyal lehet megadni, a mintaközelítés eredménye ilyen típusú.
JavaScript-ben függvény a \texttt{CustomFunction}-nel adható meg.
Ez a sztenderd Java beépített Nashorn JavaScript motorját használja.

A \texttt{Matrix} osztályban vannak megadva a valós mátrixok műveletei, mindegyik kétdimenziós \texttt{double} tömbökre.
Az implementált műveletek a legkisebb négyzetek módszeréhez szükségesekre korlátozódnak, ezek a mátrixszorzás, a transzponálás, és mátrix formában megadott lineáris egyenletrendszerek megoldása.

Lineáris egyenletrendszerek megoldhatóak a Householder-féle QR felbontással, vagy Gauss-eliminációval.
A Gauss-eliminációnál kiválasztható, hogy részleges sorcserére, vagy teljes sor és oszlopcserére kerüljön sor.
A \texttt{Solver} interfész a választott módszer részleteinek elfedésére szolgál.
A közelítések tesztjei alapján a legkisebb hibát eredményező választás a Gauss-elimináció teljes sor és oszlop cserével, a felhasználó nem tudja megválasztani a lineáris egyenletrendszerek megoldási módszerét.

A \texttt{LeastSquares} osztályban lett megvalósítva a legkisebb négyzetek módszere.
A csomag eddig felsorolt osztályaival itt lehet megadni a közelítéshez az elemi függvényeket, az összegzések és az egyenletrendszer megoldásának algoritmusát, és a közelítendő mintát.
A közelítés hibáját is ki lehet ezzel az osztállyal számolni.

\subsection{gui.io}

A \texttt{gui.io} csomagban az adatbázis kezelését leíró osztályok vannak.
Az adatbázis funkciók a \texttt{Database} egy objektumán keresztül érhetőek el, ez a \texttt{common.h}-val párhuzamosan definiálja a szegmensfájlok neveit, és formátumát.
A felhasználói műveletek közül az adatbázis információk lekérését, a szegmensfájlok összesítését, és összesítés importálását a \texttt{Database} osztály \texttt{info()}, \texttt{reaggregate()}, és \texttt{importAggreagtes()} metódusai valósítják meg.

A sziták az inicializálásukkor a \texttt{Database.largePrimes()} metódust használva olvassák be az első 4 szegmensfájlból a prímeket.

A \texttt{Segment} osztály példányai a $2^{30}$ hosszú szitatáblák.
Ezek fájlból olvasott adatokat is tartalmazhatnak, vagy szegmensek és sziták ellenőrzésekor a \texttt{gui} program is generálhatja.
Ezzel az osztállyal szegmensfájlt csak olvasni lehet, írni nem.

Ez a csomag tartalmazza a CSV fájlok olvasásához és írásához a \texttt{CSVReader} és \texttt{CSVWriter} osztályokat.
Mindkettő adatfolyamként teszi lehetővé a szöveges cellák soronkénti feldolgozását.

\subsubsection{Összesítő}

Az összesítés megvalósítása a \texttt{gui.io} csomag része.

Egy szegmens összesítését a \texttt{Segment.aggregate()} függvény végzi.
Az eredményül kapott \texttt{Aggregate} példány az adatbázis formátumánál leírt szegmensstatisztika tükre.
Az összesítőfájlt az \texttt{AggregatesReader} és \texttt{AggregatesWriter} osztállyal lehet olvasni és írni.
A szegmensek összesítései szigorúan növekedő kezdőszámú sorrendben dolgozhatóak fel.
A írás és az olvasás \texttt{AggregateBlock} példányokkal dolgozik, ezek az objektumok a statisztikához való hozzáférés mellett a betömörített bináris adatot jegyzik meg, hogy a statisztika változatlan kiírása esetén ki lehessen hagyni az időigényes betömörítést.

A megjelenítésre szánt mintákat az \texttt{Aggregates} osztály készíti el a szegmensenkénti statisztikák alapján közvetlenül a megjelenítés előtt.
A szegmenseket az összesítésfájl sorrendjében dolgozza fel, az első hiányzó szegmensig.
A megjelenített statisztikák legtöbbje egyszerűen összesíthető a szegmensenkénti adatokból.

Az összes páratlan prím számát a $4Z+1$ és a $4Z+3$ alakú prímek számának összege adja, az összes prímet ezek mellett az egyetlen páros prím, a $2$, alkotja.

Az egymás utáni szegmenseken átívelő prímhézagok egyik hézagokra vonatkozó statisztikában sem szerepelnek, ezeket a szegmensenként eltárolt legkisebb és legnagyobb szegmensbe eső prím alapján külön meg kell határozni.

\subsection{gui.sieve}

Ebben a csomagban, és a \texttt{gui.sieve.eratosthenes} alcsomagjában, a futási idők méréséhez implementált sziták vannak.

A sziták a \texttt{Sieve} osztály leszármazottai.
A példányaitól elvárás, hogy
\begin{itemize}
\item a szitálást szegmensenként végzi
\item a szitatábla bitvektorát csak korlátozottan éri el
\begin{itemize}
\item csak az éppen szitált szegmensbe eső számokat éri el
\item páros számot sose ér el
\item legfeljebb $2^{32}-1$-ig olvassa vissza a szitálás eredményét
\end{itemize}
\item a szegmens mérete szabályozható, a lehetséges értékek a kettő hatványai $2^8$-tól $2^{30}$-ig 
\item inicializáláskor a szitálás kezdő számáig beolvassa a prímek listáját az adatbáziskönyvtárból
\item a szitálás kezdetétől $2^{32}$-ig a prímeket a prímek listájába az éppen szitált szegmensből veszi
\item bármikor inicializálható a szita egy szegmens kezdetéhez úgy, hogy onnantól már további felkészülési idő nélkül lehet több egymás utáni szegmenst szitálni
\item az \texttt{OperationCounter} osztály segítségével számon tartja a szitálás műveletigényét.
\end{itemize}

\tikzumlset{fill class=white}
\begin{figure}[H]
\centering
\caption{A sziták osztály diagramja}
\begin{tikzpicture}[framed]

\umlclass[x=0.5, y=0, type=abstract]{OperationCounter}{}{
+add() \\
+get()::long \\
+increment() \\
+reset()}

\umlclass[x=5.5, y=-0.3, type=abstract]{SieveTable}{}
{+clear(prime) \\
+flip(number) \\
+isPrime(number)::boolean \\
+setComposite(number) \\
+setPrime(number)}

\umlclass[x=10, y=1]{LongTable}{}{}
\umlclass[x=10, y=-1]{Segment}{}{}
\umlclass[x=0, y=-4, type=abstract]{Sieve}{}{+reset(start) \\ +sieve()}
\umlclass[x=0, y=-7, type=abstract]{SegmentedSieve}{}{}
\umlclass[x=0, y=-9.5, type=abstract]{EratosthenesianSieve}{}{}
\umlclass[x=4, y=-4]{TrialDivision}{}{}
\umlclass[x=4, y=-6]{SieveOfAtkin}{}{}
\umlclass[x=9, y=-6]{SieveOfEratosthenes}{}{}
\umlclass[x=8, y=-8]{QueueSieve}{}{}
\umlclass[x=7, y=-10]{CacheOptimizedLinearSieve}{}{}
\umlclass[x=6, y=-12]{SimpleBucketSieve}{}{}
\umlclass[x=1, y=-12, type=abstract]{BucketSieve}{}{}
\umlclass[x=1, y=-14]{Bucket1Sieve}{}{}
\umlclass[x=5, y=-14]{BucketNSieve}{}{}

\umlinherit{LongTable}{SieveTable}
\umlinherit{Segment}{SieveTable}
\umluniassoc{Sieve}{SieveTable}
\umluniassoc{Sieve}{OperationCounter}
\umlinherit{SegmentedSieve}{Sieve}
\umlinherit{TrialDivision}{Sieve}
\umlinherit{EratosthenesianSieve}{SegmentedSieve}
\umlinherit{SieveOfAtkin}{SegmentedSieve}
\umlinherit{BucketSieve}{EratosthenesianSieve}
\umlinherit{SieveOfEratosthenes}{EratosthenesianSieve}
\umlinherit{QueueSieve}{EratosthenesianSieve}
\umlinherit{CacheOptimizedLinearSieve}{EratosthenesianSieve}
\umlinherit{SimpleBucketSieve}{EratosthenesianSieve}
\umlinherit{Bucket1Sieve}{BucketSieve}
\umlinherit{BucketNSieve}{BucketSieve}
\end{tikzpicture}
\end{figure}

A \texttt{SieveTable} osztály \texttt{Segment} implementációja az adatbázisnál is használt szegmensfájl, szita ellenőrzésekor ez a szitatábla tárolja a bitvektort, és az ellenőrzés a végeredményt hasonlítja össze a referenciaszita eredményével.
A \texttt{Segment} mindig pontosan $2^{30}$ hosszú szitatáblát reprezentál.

A \texttt{LongTable} megvalósítást a program a futási idő mérésénél használja.
A \texttt{LongTable} a teljes szitálható tartomány lefedi.
$2^{32}$-ig minden páratlan számhoz tartozó bitet nyilvántart.
Az összes $2^{32}$-nél nagyobb számhoz tartozó bit módosítása egy tömbbe képződik le.
Ez a tömb $2^{26}$ bitet tárol.
Egy számhoz tartozó bit módosításánál a ténylegesen módosított bit indexét a szám alsó $26$ bitje adja.
Így a bit módosítását a szitatábla ténylegesen elvégzi a memóriában, de ez eredmény bitjeiből nem lehet megállapítani, hogy melyik szám prím.

Mindegyik szita megvalósítása valamilyen formában eltárolja a már megtalált prímeket, de csak a szitált szegmens végének négyzetgyökéig veszik azokat figyelembe.
A sziták a prímek tárolását a \texttt{PrimitiveList} osztály használatával oldják meg, az elemek csoportosítását a listán belüli helyük adja.

Az edénysoron alapuló sziták belső edényeinek pillanatnyi mérete tág határok között mozog, azért a memóriaveszteség csökkentésére ezek ez edények kisebb, fix méretű edények láncolt listái.
Az edénysor ezeket a listaelemeket feldolgozás után újrahasznosítja a szemétgyűjtés elkerüléséhez.
A listaelemeket a \texttt{Bucket} osztály írja le.

A \texttt{CacheOptimizedLinearSieve} a prímek listáját a prímek nagysága szerint csoportosítja.
A csoportosítás tömör reprezentációja miatt kényelmesebb ezt a csoportosítást akkor elvégezni, amikor már a prímek listája az összes prímet tartalmazza.
Ezért a COLS szita $2^{32}$-ig egy egyszerű listás eratoszthenészi szitaként viselkedik, és az azutáni első szegmens szitálásakor alakítja ki a csoportosítást, és vált át az optimalizált algoritmusra.

A sziták egyszerű hierarchiát alkotnak.
A \texttt{SegmentedSieve} leszármazottai a prímek listáját a szitált szegmensek átnézésével állítják elő, és a listát eltárolják.
Az \texttt{EratosthenesianSieve} típusú sziták a prímekkel úgy szitálnak, hogy a prím eltárolt utolsó többszörösét a prím kétszeresével növelik, amíg a többszörös a szegmensbe esik.

A sziták algoritmusai a \pageref{sec:szitak} oldalon a ''Sziták'' szakaszban vannak részletesebben kifejtve.
Az implementációk főbb jellemzői:
\begin{itemize}
\item \texttt{TrialDivision}: próbaosztás
\item \texttt{SieveOfAtkin}: Atkin szitája
\item Eratoszthenész szitájának implementációi:
\begin{itemize}
\item \texttt{SieveOfEratosthenes}: a prímeket egy tömbben tárolja, és minden szegmens szitálásához minden prímmel próbál szitálni a szegmensben
\item \texttt{QueueSieve}: a prímeket bináris kupacban tárolja, szitáláskor a kupac elejét dolgozza fel, amíg az a szegmensbe esik.
\item \texttt{CacheOptimizedLinearSieve}: a prímeket kétszintű edényrendszerben tárolja, szitáláskor a szegmensbe eső elemek már edényekbe vannak válogatva, azokat csak be kell járni
\item \texttt{SimpleBucketSieve}: a prímeket a \texttt{QueueSieve}-hez hasonlóan egy elsőbbségi sorban tartja nyilván, az elsőbbségi sor egyre nagyobb intervallumokat lefedő edények listája. Ez a szita a szegmensmérettől függetlenül minden számon sorban halad végig a szitatáblában, és arról egyetlen menetben dönti el, hogy többszöröse-e valamelyik prímnek.
\item \texttt{Bucket1Sieve}: az edénysoron alapuló szita felgyorsítása a COLS 0. ''körével'', a szegmensek méreténél kisebb prímeket a sortól külön, egy tömbben tárolja. Ezek a kis prímek minden szegmensben szitálnak, felesleges lenne a sorból minden szegmensnél kivenni, majd visszahelyezni ezeket.
\item \texttt{BucketNSieve}: a \texttt{Bucket1Sieve} további gyorsítása, az edénysor számrendszerének alapját megnövelve a prímek részleges rendezését finomítja.
\end{itemize}
\end{itemize}

\subsection{gui.ui}

Ebben a csomagban a Swing használatát megkönnyítő osztályok vannak.

A program legtöbb művelete hosszú időt vesz igénybe, és a felhasználó az elindítása után már nem tudja befolyásolni.
A \texttt{gui.ui.progress} alcsomag az ilyen lassú folyamatok visszajelzését segíti.
A \texttt{Progress} interfészen keresztül egy folyamat százalékban visszaadhatja, hogy hol tart.
A \texttt{Progress.subProgress()} egy új \texttt{Progress} példányt hoz létre, ami a szülő egy részfolyamatát reprezentálja, ezzel részeljárások elöl elfedhető a teljes megoldásban elfoglal helyük.
Az interfésznek két implementációja adott, parancssorhoz a \texttt{PrintStreamProgress}, és a grafikus \texttt{GuiProgress}.
Mindkét megvalósítás ügyel arra, hogy gyakori státuszfrissítés esetén a megjelenítés ne tartsa fel a ténylegesen elvégzendő műveletet.

A lassú folyamatok megvalósításának másik segédosztálya a \texttt{GuiProcess}.
Ez az absztrakt osztály megszervezi a grafikus felületen a háttérfolyamatok futtatását.
A Swing szál feltartása helyett a lassú művelet háttérben futtatható részét egy külön szálban futtatja, a műveletet a \texttt{background()} metódusában kell megvalósítani.
A \texttt{background()} függvény lefutása után a \texttt{foreground()} metódust a Swing szálban hívja meg, az eredmény itt jeleníthető meg.
Az eredmény átadása a két szál között az osztály megvalósítására van bízva, a szálak szinkronizálásának megkönnyítésére a \texttt{background()} metódusból visszatérés garantáltan \textit{happens-before} relációban van a \texttt{foreground()} meghívásával.
A \texttt{GuiProcess} a \texttt{background()} futásához egy \texttt{GuiProgress} példányt is létrehoz, amin keresztül a háttérfolyamat vissza tudja jelezni, hogy hol tart.

\subsection{Grafikus megjelenítés}

A grafikus program fő ablakát a \texttt{gui.Gui} osztály írja le.
A program ablakai egy közös \texttt{Session} objektumon keresztül tartanak fenn szálakat a háttérfolyamatok futtatására.
Ez az objektum számon tartja a nyitott ablakok számát, és az utolsó becsukásával a háttérszálakat szabályosan leállítja.

\subsection{Parancssor}

A \texttt{gui} program legtöbb művelete parancssorból is indítható.
A parancssori műveleteket írják le a \texttt{gui.Command.Descriptor} osztály példányai. A \texttt{gui.Main.main()} a program indítási paramétereit ezekkel a leírókkal összevetve választja ki a futtatandó parancsot.
A leíró a parancs belépési pontja mellett a megengedett argumentumok listáját tartalmazza.
A parancs kiválasztásához a tényleges és elvárt argumentumok meg kell egyezzenek.
Az argumentum leírásában található reguláris kifejezéssel a \texttt{main()} szintaktikailag ellenőrzi a tényleges argumentumokat, a szemantikai helyesség ellenőrzése minden parancs saját feladata.

\subsection{Adatbázis műveletek}

Az adatbázison három művelet végezhető, ezek implementációja a \texttt{Database} osztály \texttt{info()} metódusa, ami összegyűjti az adatbázisban tárolt szegmensek információit, az \texttt{importAggregates()} a megadott és az adatbázis összesítőfájlát összefésüli, és a \texttt{reaggregate()} az új szegmensfájlokat összesíti.
Ez a két művelet a szegmens és összesítőfájl segédosztályait használja, az összefésülő rendezéshez hasonlóan ezek egyetlen menetben oldják meg a feladatot.

Egyik művelet sem interaktív, a paraméterek megadása és az eredmény visszajelzése is a legegyszerűbb megoldásokat használja grafikusan és parancssorban is.
Ezek megvalósítása a \texttt{gui.io.command} csomagban található.

\subsection{A sziták eredményeinek ellenőrzése}

A szegmensfájlok és a sziták ellenőrzése a \texttt{gui.check} csomagban van megvalósítva.
Mindkettő parancssorból és grafikusan is indítható, az adatbázis műveletekhez hasonlóan a paraméterek bekérése és az eredmény megjelenítése a legegyszerűbb eszközöket használja.

Mindkét művelet az ellenőrzéseket szegmensenként végzi.
Az összehasonlításhoz a \texttt{ReferenceSegment} osztály állítja elő a referenciának vett szitatáblát.
A szitatáblát a \texttt{ReferenceSegment.SIEVE} példány Eratoszthenész szitával készíti el, a \texttt{ReferenceSegment.TEST} az erős pszeudoprím teszttel.

A pszeudoprím teszt a referenciaként használt szegmens előállításához a szegmens minden számára végrehajtja a determinisztikus Miller-Rabin pszeudoprímtesztet.
Ehhez szükséges a módszer teljességét $2^{64}$-ig garantáló alapot választani.
A módszer leírását és az alapot \cite{pseudoprimebase}-ben lehet megtalálni.

A \texttt{CheckSegments.checkSegments()} metódus végzi a szegmensek ellenőrzését, a kiválasztott szegmensek beolvasását, a referencia generálását, és az kettő összehasonlítását.
A \texttt{CheckSieve.checkSieve()} metódus ehhez hasonlóan működik.
Az ellenőrizni kívánt szegmenseket a kiválasztott szitával állítja elő, és az ellenőrző szegmensek előállítását mindig a \texttt{ReferenceSieve.SIEVE}-vel végzi.

\subsection{Grafikon ábrázolása}

A grafikonok megjelenítése a program egyetlen interaktív része, ennek kezelésére a modell-nézet-vezérlő mintát használja.
A modell a megjelenítendő minták és függvények, valamint a grafikon megjelenítendő intervalluma.
A nézet a sztenderd Swing komponenseket használja.
A vezérlő a \texttt{gui} segédosztályaira épít.

A modell alapján a megjelenítéshez szükséges grafikus utasítások előállítása időigényes. A mintákat és a függvényeket pixel széles intervallumokon mintavételezve határozza meg a képernyő egy oszlopához tartozó minimum és maximum értékeket.
Az interaktivitás érzésének fenntartásához az oszlopokra bontást a program egy háttérszálban végzi, és közben a részeredményeket rendszeresen átadja a nézetnek megjelenítésre.
A felhasználó a háttérszámítások közben a modellt módosítva az addigi előszámításokat elveszíti, és egy új háttérszál indul.

\tikzumlset{fill object=white}
\begin{figure}[H]
\centering
\caption{Új modell megjelenítésének szekvencia diagramja}
\begin{tikzpicture}[framed]
\begin{umlseqdiag}
\umlobject{Swing}
\umlobject[x=2]{vezérlő}
\umlobject[class=GraphPlotter, x=6]{nézet}
\begin{umlcall}[dt=5, op=getGraph(), with return]{vezérlő}{nézet}
\end{umlcall}
\begin{umlcall}[dt=5, op=setGraph()]{vezérlő}{nézet}
\umlcreatecall[class=GraphRenderer, x=11]{nézet}{háttérszál}
\end{umlcall}
\begin{umlcall}[dt=8, op=checkAndPost()]{háttérszál}{nézet}
\begin{umlcall}[op=paint(), type=asynchron]{nézet}{Swing}
\end{umlcall}
\end{umlcall}
\begin{umlcall}[dt=5, op=checkAndPost()]{háttérszál}{nézet}
\begin{umlcall}[op=paint(), type=asynchron]{nézet}{Swing}
\end{umlcall}
\end{umlcall}
\begin{umlcall}[dt=5, op=checkAndPost()]{háttérszál}{nézet}
\begin{umlcall}[op=paint(), type=asynchron]{nézet}{Swing}
\end{umlcall}
\end{umlcall}
\end{umlseqdiag}
\end{tikzpicture}
\end{figure}

\subsubsection{Modell}

A modell osztályai a \texttt{gui.graph} csomagban vannak.
A modellt a \texttt{Graph} osztály írja le.
Ez egy nem módosítható konténerosztály, az ábrázoláshoz szükséges összes paramétert tartalmazza:
\begin{itemize}
\item a mintákat, ezeket a \texttt{Sample} osztály írja le
\item a függvényeket, ezeket a \texttt{Function} osztály írja le
\item a grafikon ábrázolására használható képernyőrész szélességét és magasságát pixelekben
\item a grafikon megjelenített részét, amit a mintatér koordináta rendszerében lehet megadni egy téglalap sarkaival
\item a megjelenítéshez használt színeket
\end{itemize}

A \texttt{RenderedGraph} osztály tartalmazza a minták és függvények oszlopokra bontását.
A \texttt{Graph} osztályhoz hasonlóan ennek az osztálynak a példányai se módosíthatóak.
A \texttt{RenderedGraph} tartalmazza a hozzá tartozó \texttt{Graph} referenciáját is, ezzel mindig ellenőrizhető, hogy a két modell objektum egymáshoz tartozik.

A \texttt{RenderedSample} osztály írja le az oszlopok mintavételezésének eredményét.
Függvényből származó oszlopminták egybefüggő, diszjunkt intervallumonként csoportosítva vannak a \texttt{RenderedInterval} osztály segítségével.
Ha az oszlopminta mintából származik, akkor egyetlen \texttt{RenderedInterval} példányba kerül az összes oszlopa.

Ezeknek az osztályoknak a módosíthatatlansága megkönnyíti a helyes többszálú feldolgozást.
Egy kész objektumot egy szál sem fog megváltozni látni, és a referenciák megjegyzésével könnyen követhető, hogy melyik a legújabb modell.

A grafikon oszlopokra bontását a \texttt{GraphRenderer} osztály vezérli.
A minták felbontásához pixel széles oszlopok intervallumán megkeresi a legkisebb és a legnagyobb mintaértéket, és az összes ilyet egyetlen \texttt{RenderedInterval}-ba teszi.
A mintákat a nézet minden kitöltött oszlop között összeköti egy vékony egyenessel.
Ahhoz, hogy a megjelenítés szélein túlra is be legyen húzva ez az egyenes, az oszlopmintába a megjelenített intervallumtól balra és jobbra eső mintaelem is bekerül.

Függvények előkészítésénél az eljárás ehhez nagyon hasonló.
Az oszlop minimum és maximum értékét pontos módszer helyett mintavételezéssel határozza meg. Az oszlop intervallumában több, egyenletes távolságra lévő ponton kiértékeli a függvényt, és ezekből határozza meg az értékeket.
A függvény oszlopmintájában az intervallumok összefüggőek, a függvény az intervallum legelső oszlopának bal szélétől a legutolsó oszlop jobb széléig értelmezve van.
A nézet ennek megfelelően az értelmezett intervallumok közötti szakaszokon semmit nem rajzol ki.

A \texttt{GraphRenderer} a nézettel a \texttt{CheckAndPost} interfészen keresztül kommunikál a pontos nézetimplementáció ismerete nélkül.
A \texttt{check()} metódussal le tudja ellenőrizni, hogy a legújabb modell az-e, amit éppen feldolgoz.
A \texttt{checkAndPost()} metódussal az ellenőrzés után az addig elkészült részeredményt tovább is adja megjelenítésre.
Ha a modell már elavult, a \texttt{check()} és \texttt{checkAndPost()} metódusok egy \texttt{RendererDeathException}-t dobnak, és a \texttt{GraphRenderer} hibajelzés nélkül leáll.
Ez csak akkor fordulhat elő, ha egy másik szálon már dolgozik egy új \texttt{GraphRenderer}, ami előállítja az új megjeleníthető modellt.

\subsubsection{Vezérlő}

A grafikon megjelenítésének ablaka a \texttt{Plotter} osztály.
A vezérlő ennek az ablaknak az eseménykezelői, amik a modell módosításán keresztül tudják módosítani a megjelenített grafikont.
A modellen végezhető műveletek:
\begin{itemize}
\item a grafikon megjelenített részének mozgatása, nagyítása, kicsinyítése
\item minta hozzáadása
\item minta törlése
\item minta közelítése
\item közelítő függvény törlése
\end{itemize}
Ezek megvalósítására a program a Swing sztenderd komponenseit használja.

A mintát a modellhez adni három forrásból lehet.
Az adatbázis összesített statisztikáiból, ezek előállítása az \texttt{Aggregates} osztály feladata.
Be lehet tölteni mintát CSV fájlból, ezt a \texttt{LoadSampleProcess} oldja meg.
Vagy meg lehet mérni egy szita futási idejét.
A futási idő mérése a parancssorból indítható mérést használja, a \texttt{MeasureSieve} ablak a mérés paramétereinek megadására szolgál.

A minta közelítésének számítási részét a \texttt{gui.math} csomag végzi.
Az elemi függvények kiválasztása a \texttt{FunctionSelector} ablakban lehetséges.
Elemi függvényt JavaScript nyelven a \texttt{CustomFunctionDialog} ablakban lehet megadni.

A \texttt{GraphPlotter} komponens a grafikon egérrel történő mozgatásáról, nagyításáról, vagy az ablak méretének változásáról eseményeket küld a vezérlésnek, így a nézet csak a vezérlésen keresztül módosítja a modellt.

\subsubsection{Nézet}

A nézetet a \texttt{GraphPlotter} osztály reprezentálja.
A két részből álló előkészített modell megjelenítése a grafikus vezérlőutasítások kiadásából áll.

Ennek a komponensnek a \texttt{graph} adattagja tartalmazza a legújabb modell értéket, a vezérlés, az előkészítés, és a megjelenítés ezen keresztül kommunikál.
A modell módosításakor a \texttt{GraphPlotter} objektum a \texttt{graph} adattag cseréjével biztosítja, hogy a régi modellre vonatkozó háttérszál leáll, és elindítja az új modell oszlopra bontását.
Az előkészített modellről a \texttt{CheckAndPost} eseménykezelőjén keresztül értesül, aminek hatására ütemezi az új grafikon kirajzolását.
A tényleges kirajzolásnál még egyszer ellenőrzi, hogy a grafikon a komponens tényleges méretére készült el, majd a már elkészült grafikon-részeket kirajzolja.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "szakdolgozat"
%%% End:

\chapter{Fejlesztői dokumentáció}

\section{A feladat leírása}

A program feladata, hogy lehetővé tegye prímsziták futási idejének összehasonlítását.
A prímsziták az egész számok egy intervallumán
minden számról eldöntik, hogy a szám prím, vagy összetett.
A program keretet ad, hogy azonos paraméterekkel lehessen a sziták futási idejét mérni,
és egyszerű, egymáshoz hasonlóan optimalizált szitákat implementál,
hogy a futási időket a fő algoritmusok határozzák meg, mivel a szitálást felgyorsító
egyes ötletek nem minden szitán alkalmazhatóak.
A futási időt eltelt időben, és összeszámolt műveletekben is méri.

A szitákat szegmentáltan valósítja meg,
a szegmensek mérete, és a szitálandó intervallum
kezdete és vége szabályozható. A megvalósított sziták:
\begin{itemize}
\item Atkin szitája
\item Eratoszthenész szitája
\begin{itemize}
\item egyszerű tömbbel
\item bináris kupaccal
\item edényekkel
\item monoton edénysorral
\end{itemize}
\end{itemize}

A programnak grafikusan ábrázolja a futási időket, és lehetőséget ad
ezek közelítésére függvényekkel. A közelítéshez a legkisebb négyzetek módszerét használja,
és a közelítés elemi függvényei megválaszthatóak.
A program megjeleníti a közelítések négyzetes eltérését is a mintához képest.
Elemi függvény meg lehet adni JavaScript nyelven is.

A grafikus ábrázolás képes külső forrásokból származó minták megjelenítésére és közelítésére is.

A minták és függvények ábrázolása interaktív, az éppen megjelenített
intervallum elhelyezkedése és mérete megválasztható.
Egyszerre több mintha is megjeleníthető,
és minden mintához egyszerre több közelítő függvény is tartozhat.

A prímszámok statisztikáinak megjelenítéséhez
elő tudja állítani ezeket a statisztikákat nagyobb intervallumokon is.
Ehhez ad egy szitát, ami hatékonyan képes $2^{64}$-ig szitálni,
és ennek az eredményét összesíteni. Az előállítható statisztikák
adott $n$-ig szitálva:
\begin{itemize}
\item a prímek száma
\item a $4\mathbb{Z}+1, 4\mathbb{Z}+3, 6\mathbb{Z}+1, 12\mathbb{Z}+11$
	alakú prímek száma
\item ikerprímek számát
\item az előforduló prímhézagok első előfordulásának helye
\item a prímhézagok előfordulásának száma
\item a szitálásra fordított idő
\end{itemize}

A prímek számát, és a szitálás idejét az intervallum belsejében is több ponton elkészíti.

A sziták sebességének mérését, és a statisztikák előállítását
parancssorból is el tudja végezni, hogy szkriptekkel ez automatizálható legyen.
A statisztikák előállításának folyamata
bármikor adatvesztés leállítható, és később folytatható.

%%% EMLI: kb eddig olvastam, a többin csak átfutott a szemem... majd mindjárt írok levelet.
\section{A program komponensei}

{\color{red}Ábra.

init -> db -> generátor -> db -> összesítő -> db -> minta megjelenítés -> minta közelítés -> közelítés megjelenítés

db -> info

db -> sziták -> futási idő minta -> minta megjelenítés -> minta közelítés -> közelítés megjelenítés

db -> ellenőrzés

db -> sziták -> ellenőrzés
}

A program az adatbáziskönyvtárban tárolja az átszitált szegmensek tábláit,
és az ezekből készült statisztikákat. A szegmensfájlokban egy $2^{30}$ hosszú
intervallum minden páratlan számához hozzá van rendelve, hogy az az szám
összetett vagy prím, és minden szegmens kezdő száma kongruens $1 (mod\ 2^{30})$.

Az első négy szegmenst az init program készíti el, így ezek $2^{32}$-ig tartalmazzák
a prímszámokat. A program többi szitája ezek alapján inicializálja magát,
ha $3$-nál nagyobb számtól kell a szitálást elkezdeni.
Ez a négy fájl bármikor újragenerálható, de ezeket érdemes a futások között megtartani.

A generátor egy optimalizált szita, $2^{32}$-től $2^{64}-2^{34}$-ig képes szitálni,
mindig egész szegmenseket, és az eredményt az adatbáziskönyvtárba menti.
Ezekre a szegmensfájlokra összesítés és ellenőrzés után többet nincs már szükség.
A szitálást tetszőleges szegmenstől lehet kezdeni a megengedett tartományon belül,
nem szükséges sorban végigmenni a számokon.
Az utolsó $2^{34}$ szám kihagyása egyszerű
optimalizáció, így a programban az éppen
szitált szám változója sosem csordul túl.

Az init és a generator csak konzol módban futtatható.
A program többi része a gui nevű Java program része,
de az automatizáláshoz az adatbázissal kapcsolatos műveletei
parancssorból is elérhetőek, ezek az adatbázis információ lekérése, az új szegmensfájlok ellenőrzése, és összesítése, és az összesítőfájlok összefésülése.
Az időigényessége miatt a futási idő összehasonlításához implementált sziták ellenőrzése is futtatható grafikus felületen, és parancssorból is.

Az adatbázis információ kilistázza a szegmensfájlok számát,
az összesített szegmensfájlok számát, ezen szegmensek intervallumának kezdetét és végét, a még nem összesített szegmensfájlok számát.
Ezek alapján eldönthető, szitálást vagy az összesítést hogyan kell folytatni, hogy a teljes $2^{64}$-ig intervallum statisztikái elkészüljenek.

A szegmensfájlok ellenőrizhetőek, ehhez egy, a generator-tól különböző eratosthenészi szita, vagy az erős pszeudo-prímteszt előállítja a szegmens ellenőrzött részét, és a program a kettőt összehasonlítja.
A szita lényegesen lassabb, mint a generator, és a pszeudo-prímteszt időigénye miatt intervallumok szitálásra nem alkalmas, a szegmensfájlok ellenőrzése alapvetően a generator helyességének
tesztelésére való, minden összesített szegmens ellenőrzése megtöbbszörözné a szükséges időt.

Az összesítő az adatbáziskönyvtárban található szegmensfájlok statisztikáit készíti el, és ezeket a szegmensstatisztikákat szintén az adatbázisban tárolja.
A szegmensstatisztikák alapján a végső statisztikákat közvetlenül a megjelenítés előtt készíti el az összesítő.
Az összesítéshez sem szükséges, hogy a szegmensek sorban kerüljenek összesítésre, így akár több gépen párhuzamosan is lehetne szitálni, összesíteni, majd az eredményt összefésülni.

A program része több, különböző algoritmusú prímszita.
Ezeknek az eredménye ellenőrizhető a szegmensfájlok ellenőrzéséhez használt szitával, szintén a sziták helyességének teszteléséhez.
A feladat része, hogy ezeknek a szitáknak a futási idejét össze lehessen hasonlítani, ezért mindegyik szita néhány jól meghatározott ötlet egyszerű megvalósítása optimalizálások nélkül.
Mindegyik szita szegmentált, a szitálást fix hosszúságú intervallumokon végzi, bármelyik szegmenstől képes kezdeni a szitálást, és egy szegmens szitálása után további előkészület nélkül képes szitálni a következő szegmenst, így egyetlen menetben akár több szegmenshez tartozó futási idő is megmérhető, nem szükséges minden mintavételi pontig a teljes szitálást elvégezni.

A minták közelítése alapfüggvények lineáris kombinációjával történik, a legkisebb négyzetek módszerét használva.

A program a mintákat és közelítő függvényeket Descartes-féle koordináta rendszerben jeleníti meg, ehhez a mintákat és a függvényeket mintavételezi az x tengely kiválasztott szakaszának pixelenkénti felosztása szerint.

\section{Az adatbázis}

A program adatbázisa két fajta adatot tárol, a szitált szegmenseket, azaz a szitatábla bitvektorait, és a szegmensek összesítéseit.
Mindkettő a szegmens első számával van azonosítva, a szegmens hossza mindig $2^{30}$ szám, és az $n \in \mathbb{N}$ megengedett kezdő szám, ha $n < 2^{64}-2^{34}$ és $n \equiv 1 \pmod{2^{30}}$.
Minden szegmens egy külön fájl az adatbázis könyvtárában, és az összes szegmensstatisztika egy fájlban van.

Az init program az első 4 szegmensfájlt írja, a generator az első 4 szegmensfájlt olvassa, és az összes többi szegmensfájlt írja, a gui az összes szegmensfájlt olvassa, és egyiket se írja, és szegmensstatisztika fájlt csak a gui használja.

Egy szegmensfájlok nevei ''primes.'' előtaggal kel kezdődjön, és a pontosan 16 hexadecimális számjegy kell kövesse, ami a szegmens által leírt első szám.
A fájl bináris fájl, {\color{red}little endian} sorrendben.
A tartalma:
\begin{itemize}
\item a szegmens elejével kezdve $2^{29}$ egymást követő páratlan szám bitvektora.
	
Ez $2^{26}$ byte, {\color{red}little endian} sorrendben minden bit egy szám összetettségét írja le.
Ha a bit $1$, akkor a szám összetett, ha $0$, akkor a szám prím.
Ha $s$ a szegmens intervallumának kezdete, akkor az $0.$ bájt $0.$ bitje $s$-t írja le, a $0.$ bájt $1.$ bitje $s+2$-t, a $k.$ bájt $l.$ bitje $s+16k+2l$-t.
	
\item a szegmens kezdete, 8 bájt, egész
\item a szegmens szitálására való felkészülés ideje, 8 bájt, egész, nanoszekundumokban
\item a szegmens szitálásának ideje, 8 bájt, egész, nanoszekundumokban
\end{itemize}

Ahhoz, hogy az init és a generator program bármikor leállítható legyen szegmensfájl írása közben, a szegmenst először egy ideiglenes fájlba írja, és ha ez hiba nélkül megtörtént, akkor az ideglenes fájlt átnevezi a megfelelő névre.
Mivel az ideiglenes fájl ugyanabba a könyvtárba kerül, mint ahova a szegmensfájl is, így feltételezhető, hogy helyi meghajtón az átnevezés már atomi művelet.

Ez az eljárás az átnevezés előtt nem győződik meg arról, hogy az ideiglenes fájl minden része
kiíródott a háttértárra, így ez csak a program leállíthatóságát garantálja, a számítógép váratlan leállása esetén érdemes azokat a szegmensfájlokat letörölni, amikről feltételezhető, hogy nem volt ideje a számítógépnek minden részét kiírnia a tényleges tárolóra.

A szegmensstatisztikák az ''aggregates'' fájlban vannak. A szegmensek a fájlban a kezdőszámok sorrendjében követik egymást, egy szegmensnek legfeljebb egy statisztikája lehet.
A fájl bináris, a bájtok {\color{red}big endian} sorrendben követik egymást. A fájl fejléce
\begin{itemize}
\item {\color{red}magic number}: 0xd1d1b0b0, 4 bájt
\item verziószám: 1, 4 bájt.
\end{itemize}
Ezután minden statisztika egy változó méretű blokkban van tárolva, a fájl végéig. Minden block két részből áll, az első 4 bájt a második rész mérete bájtokban. Ez a második rész a szegmensstatisztika. A statisztika gzip-pel tömörített,
kitömörítve bináris adat, {\color{red}big endian sorrendben}, aminek a formátuma
\begin{itemize}
\item a szegmens összesítésének futási ideje, 8 bájt, nanoszekundumokban
\item a szegmens szitálásának inicializálásának ideje, 8 bájt, nanoszekundumokban
\item az összesített szegmensfájl utolsó módosításának ideje, 8 bátj, milliszekundumokban, 1970.1.1. 00:00:00-tól
\item a szegmensben található legnagyobb prím, 8 bájt
\item a szegmensben található legkisebb prím, 8 bájt
\item a $12\mathbb{Z}+11$ alakú prímek száma a szegmensben
\item a $4\mathbb{Z}+1$ alakú prímek száma a szegmensben
\item a $4\mathbb{Z}+3$ alakú prímek száma a szegmensben
\item a $6\mathbb{Z}+1$ alakú prímek száma a szegmensben
\item a szegmensben előforduló prímhézagok számát, 4 bájt. ahány prímhézag előfordult, annyiszor ismétlődik a következő három mező
\begin{itemize}
\item a prímhézag nagysága, 8 bájt
\item a prímhézag előfordulásainak száma, 8 bájt
\item a prímhézag első előfordulása, 8 bájt
\end{itemize}
\item a szegmens sorszáma, 8 bájt
\item a szegmens vége, 8 bájt
\item a szegmens kezdete, 8 bájt
\item a szegmens szitálására fordított idő, 8 bájt, nanoszekundumokban.
\end{itemize}

Az összesítésfájl írása a szegmensfájl írásához hasonló.
Egy ideiglenes fájlba írása után a program megvárja, hogy a fájl tartalma a háttértárolóra íródjon, majd az ideiglenes fájlt átnevezi a megfelelő névre.
Az ideiglenes fájl kiírásának megvárásával a statisztikafájl váratlan számítógép leállás esetén is visszaállítható.

A fájl formátuma és az új fájl kiírásának algoritmusa lehetővé teszi, hogy a statisztikafájlt egyszerre lehessen sorban felolvasni, és az új eredményt sorban kiírni, úgy, hogy egyszerre csak egy statisztikát kelljen a memóriában tartani.

Az adatbázis nincs védve a párhuzamos írásoktól, és az összesítőfájl egyszerű sorban feldolgozhatósága feltételezi, hogy egy fájl kevés szegmensstatisztikát fog tartalmazni, legfeljebb. kb. $10^6$ szegmensét.

\section{A megvalósítás}

A megoldás 3 programból áll, az init és a generator C nyelven készült el, az összes többi részfeladat a gui nevű Java nyelven írt programban lett megoldva.

\subsection{Init és generator}

Az init és a generator forráskódja a tarball generator könyvtárában van.
A két program egymáshoz nagyon hasonló feladatot lát el, hasonló megoldásokkal.
Mindkettő $2^{30}$ hosszú intervallumokat szitál, és az eredményt szegmensfájlokba írja.
Ehhez mindkettő Eratoszthenés szitáját használja.
Mindkét program ezt az egyetlen feladatot oldja meg, és szkriptekkel automatizált, kötegelt futásra van tervezve.

\subsubsection{Közös rész}

A két program közös kódja a common.h fájl.
Ez a fájl tartalmazza a konstansokat, és az eljárásokat, amik megkönnyítik a POSIX hívások használatát.
A legtöbb ilyen könnyítés a hibák kezelésének elfedése, ami a kötegelt futtatáshoz illeszkedően
a hiba kijelzése utáni azonnali programleállás.
Az I/O műveleteket könnyítik meg a readFully/writeFully
eljárások.

A sziták belső, kis szegmensmérete a
SEGMENT\_SMALL\_SIZE\_BITS\_LOG2 konstanssal
szabályozható, és a measure-generator szkript
kimenete alapján egy adott géphez igazítható.

A szegmensfájlok olvasására és írásara a readSegment() és writeSegment() függvények szolgálnak.

\subsubsection{Init}

Az init program előállítja az első 4 szegmens fájlt, azaz $2^{32}$-ig az összes prímet megkeresi.
Ezzel a többi részprogram már a $2^{32} - 2^{64}$ tartomány tetszőleges részén tud szitálni, anélkül, hogy a szitált szegmenseket a szitálás után végig kéne nézze új prímekért.

A szita egy egyszerű szegmentált eratoszthenészi szita.
A $2^{30}$ hosszú szegmenseket több kisebb, egyenlő szegmensre osztja, és ezeket a kis szegmenseket
egymás után szitálja a prímek listáján végigmenve.
A prímek mellett a következő szitálás helyét is eltárolja, így nem kell minden szegmens szitálásának elején minden prímhez osztással meghatározni, hogy melyik a legkisebb szám a szegmensben, amit az oszt.
Így egy kis szegmensben egy prímre a következő algoritmus fut le.
Ez az algoritmus visszatérő minta a szegmentált szitákban.

\begin{algorithmic}[1]
\State p: \text{a prím}
\State q: \text{a következő szám, amit p oszt}
\State e: \text{a szegmens vége}
\While{q < e}
	\State \Call{Megjelöl}{q}
	\State q = q + 2p
\EndWhile
\end{algorithmic}

A prímek listáját elég $2^{16}$-ig előállítai, ezt a program próbaosztással végzi el.

\subsubsection{Generator}

A generator fő részei hasonlóak az init-hez.
Indulása után felolvassa az összes prímet az első 4 szegmensfájlból, és mindegyik prímhez osztással meghatározza, hogy melyik a legkisebb szám, amit oszt, és legalább akkora, mint legelső
szitálandó szegmens kezdete.
A prímek, és a hozzájuk tartozó következő szitálandó
pozíciót tároló adatstruktúra szitálás közben
nem érzékeny azokra az elemekre, amik az éppen szitált szegmensnél
nagyobb helyeken szitálnak, így a generator
az összes prímet eltárolja $2^{32}$-ig, nem csak
a szitálandó tartomány végének négyzetgyökéig,
és a prímek első többszörösét is a prím
négyzetétől szitálja.

A prímek listájának inicializálása után
a nagy szegmenseket az inithez hasonlóan kisebbekre osztja,
és ezeket sorban szitálja a prímek listája alapján.

A prímek listája a generatorban több külön
adatszerkezet összessége. A prímeket a szita
inicilizálásánál 3 részre osztja a nagyságuk szerint.
A $64$-nél kisebb prímeket $64$-bit széles bitmintákban
tárolja, és ezekkel a mintákkal $64$-bitesével szitálja
végig a kisszegmenseket a bitenkénti vagy művelettel.
A 3 és a 11, valamint az 5 és a 7 szorzata kisebb, mint 64,
ezeket a párokat egyetlen $64$ bites mintába fejti ki,
ezeknek a mintáknak a periódisa 33, és 35.
A többi prím mintájának periódusa a legnagyobb olyan szám,
ami 64-nél kisebb, és a prím osztja.

A prímek, amik $64$-nél nagyobbak, de a
kis szegmensek hosszánál kisebbek, azaz minden kis szegmensben
szitálnak, az init-hez hasonlóan egy egyszerű tömbbe
kerülnek, és ugyanúgy szitál ezekkel a program, mint
az init-ben.

A kis szegmensek hosszánál nagyobb prímek
egy kis szegmensben legfeljebb egyszer szitálnak,
és van olyan szegmens, ahol egyszer sem.
A generator ezeket a prímeket egy prioritásos
sorban tárolja, amiben az elemek sorrendjét
a következő szegmens száma határozza meg,
amiben az a prím szitálni fog, a szegmensen
belüli sorrendet a sor nem veszi figyelembe.
Ezeknél a nagy prímeknél nem csak a páros
többszörösöket ugorja át a szita, hanem
a 3-mal és 5-tel osztható többszörösöket is
kihagyja. {\color{red}mi a kerék magyarul?}

Az edénysor algoritmusának részletes leírására egy későbbi fejezetben kerül sor.
Az ott leírt távolság függvényt implementálja a bucketIndex függvény
a forráskódban. A számrendszert a BUCKET\_BITS konstans szabályozza.
A sorhoz tartozó edények listája a buckets tömb, ennek minden eleme
egy láncolt lista, ahol a listaelemek fix méretű edények.

A program futása alatt a sor elemeinek száma nem változik,
de az elemek az edények között mozognak. A sor legkisebb elemeinek,
azaz az aktuális szegmensben szitáló prímek megkereséséhez
a lista egyik edényének minden elemét
megvizsgálja, ha egy elem az aktuális
szegmensben nem szitál, akkor az elemet a sorba visszahelyezi,
a távolság függvény szerint már közelebbi edénybe, ha pedig
az elem szitál az aktuális szegmensben, akkor elvégzi a szitálást,
és az elemet visszateszi a sorba, azon pozíció szerint, ahol a
prím legközelebb szitálni fog.

A 2, 3, és 5 többszöröseinek hatékony kihagyásához
a prioritásos sor elemeiben a pozíció mellett el van tárolva,
hogy az a pozíció melyik modulo 30 maradékosztály eleme.
A nyolc szóba jöhető lehetőség közül a PrimePosition.prime mező
felső 3 bitje választ. Ezt a 3 bit információt biztonsággal
lehet itt tárolni, a 64 bit széles változóból a feladat határai
miatt mindig csak az alsó 32 tartalmaz értékes számjegyet.
A {\color{red}2-3-5 kerék} alapú gyorsítás csak a prioritásos sorban
tárolt nagy prímekre van alkalmazva.

\subsection{Gui}

A program Javaban írt része tartalmazza az összes többi funkció megvalósítását, a szegmensfájlok feldolgozását, a különböző szitákat, és a minták megjelenítését.
Ezeknek a funkcióknak a többsége nem interaktív, a felhasználó a paraméterek megadása után a végrehajtást már nem tudja befolyásolni.

A forráskód ennek megfelelően három egymástól jól elkülöníthető részre osztható.
A legalsó szint a program adatszerkezeteit, algoritmusait, és fájlformátumait írja le. 
Erre építenek a felhasználói műveletek megvalósításai.
Mindegyik művelethez tartozik egy eljárásként megvalósított belépési pont,
a programkód legfelső szintje ezeket teszi a felhasználó számára meghívhatóvá, parancssorból és grafikusan is.

A grafikonmegjelenítés az egyetlen ténylegesen interaktív feladat, ennek megoldása a modell-nézet-vezérlő felosztást alkalmazza.

{\color{red}class diagram}

\subsubsection{gui.util}

A csomag néhány közismert algoritmust és adatszerkezetet tartalmaz, valamint az ezekhez szükséges funkcionális interfészek definícióit.
A legtöbbnek létezik könnyen használható sztenderd könyvtári megvalósítása, de ezek referenciatípusokat használnak.
A primitív és referencia típusú értékek közötti rengeteg konverzió három problémát okoz.
Feleslegesen növeli a futási időt, miközben egyetlen számítógépen szitálva $2^{64}$-ig reménytelenül hosszú feladat.
Ezen túl megnöveli a program memóriaigényét.
$2^{32}$-ig kb. $2\cdot10^6$ darab prím van, ha egy szita csak a prím-pozíció párokat egy egyszerű tömbben tárolná, prímenként 4 bájton, pozícionként 8 bájton, akkor ez a tömb kb. $2,4$Gb memóriát foglalna el.
A program a primitív típusokon alapuló konténerekkel képes $3,5$Gb memória használatával futni.
A harmadik probléma az, hogy primitív érték objektummá alakítása szinte mindig új objektum allokálásával jár, ami legtöbbször egy objektum elérhetetlenségéhez is vezet.
A szemétgyűjtő ezzel járó folyamatos háttérmunkája nem csak feleslegesen növeli a futási időt, hanem kiszámíthatatlanságával megnöveli a sziták mért futási idejének zaját.

A PrimitiveList osztály és leszármazottai az ArrayList mintájára szükség szerint növekvő vektorok. Konkrét megvalósítások a double, int, és long primitív típusokra vannak.

A BinarySearch és a QuickSort a bináris keresés és a {\color{red}quicksort} algoritmusát valósítják meg absztrakt módon elért tömb felett. Az elemeket közvetlenül sosem érik el, az összehasonlításokat és a cseréket interfészeken keresztül végzik index alapján.

A BinaryMinHeap egy bináris kupac, mint absztrakt konténerosztály, az elemek típusától függő műveleteket absztrakt metódusként határozza meg.
A műveletek felteszik, hogy az elemek indexelhetőek, mint egy tömbben.
A kupac egy elsőbbségi sor, a sor eleje az absztrakt rendezés szerinti legkisebb elem.

\subsubsection{gui.math}

Ebben a csomagban az osztályok két részre oszthatóak.
Az UnsignedLong a Java long típus előjel nélküli műveleteit valósítja meg.
A Java a 8-as verziótól támogatja a primitív egész típusok előjel nélküli összehasonlítását és osztását, ez az osztály ezekre építve ad néhány segédeljárást.
A pszeudoprím-teszthez a maradékos hatványozás Java támogatás nélkül a kitevő bitjei alapján az ismételt szorzást és négyzetre emelést használja, míg a szorzás ehhez hasonlóan összeadást és kétszerezést. Ezeknek az algoritmusoknak a futási ideje egy-egy szám esetén elfogadható, de intervallumok szitálására nem alkalmas.

A csomag többi osztálya a legkisebb négyzetek módszerének implementációja, és annak segédosztályai.
A Sum double típusú értékek véges összegeit számolja ki.
A double véges pontosságú reprezentációjának következménye, hogy többtagú összeg eredménye függhet a tagok összeadásának sorrendjétől, azaz hiba keletkezhet.
A Sum három stratégiát ad ennek minimalizálására.
A program használata közben a felhasználó ezek közül nem tud választani, {\color{red}a tesztek alapján legstabilabbnak ítélt elsőbbségi soron alapuló} összegzést használja a közelítés.
A legegyszerűbb Sum.Simple a tagokat felsorolásuk sorrendjében adja össze. 
A bináris kupacot használó Sum.Priority a tagokat a sorban gyűjti, majd a végső összeg kiszámításához a sorból, amíg lehet, ismételten kiveszi a két legkisebb abszolút értékű elemet, azokat összeadja, és az eredményt a sorba visszahelyezi. A végeredmény a sorban maradó érték lesz.
A Sum.Array nagyságrend szerinti részösszegeket tart nyílván, új tagot a nagyságrendjéhez tartozó részösszeghez adja hozzá. A nagyságrend a double érték IEEE 754 szabvány szerinti reprezentáció kitevője.

A RealFunction interfész valóshoz valóst rendelő függvények reprezentációi.
Egy függvény a helyettesítési értékén kívül az értelmezési tartományáról is információt kell adjon.
A grafikonmegjelenítő az x-tengely egy pixel által lefedett intervallumán akkor jelenít meg értéket, ha az az intervallum az értelmezési tartomány része.
A Functions osztály a beépített elemi függvényeket tartalmazza.
JavaScript-ben függvény a CustomFunction-nel adható meg.
A LinearCombinationFunction már létező függvények lineáris kombinációja.
A mintaközelítés eredménye ilyen típusú.

A Matrix osztályban vannak megadva a valós mátrixok műveletei, mindegyik kétdimenziós double tömbökre.
Az implementált műveletek a legkisebb négyzetek módszeréhez szükségesekre korlátozódnak.
A Gauss-eliminációnál kiválasztható, hogy részleges sorcserére, vagy teljes sor és oszlopcserére kerüljön sor.
{\color{red}A tesztek alapján a teljes csere egyértelműen csökkenti a számítás hibáját, a felhasználó részleges sorcserét nem is tud választani.}

A LeastSquares osztályban lett megvalósítva a legkisebb négyzetek módszere. A csomag eddig felsorolt osztályaival itt lehet megadni a közelítéshez, a mintán kívül, az elemi függvényeket, és a pontosságot szabályozó paramétereket.
A közelítés hibáját is ki lehet ezzel az osztállyal számolni.

\subsubsection{gui.io}

A gui.io csomagban az adatbázis kezelését leíró osztályok vannak.
Az adatbázis funkciók a Database egy objektumán keresztül érhetőek el, ez a common.h-val párhuzamosan definiálja a szegmensfájlok neveit.
A felhasználói műveletek közül az adatbázis információk lekérését, a szegmensfájlok összesítését, és összesítés importálását Database osztály info(), reaggregate(), és importAggreagtes() metódusai
valósítják meg.
A sziták az inicializálásukkor a Database.largePrimes() metódust használva olvassák be az első 4 szegmensfájlból a prímeket.

A Segment osztály példányai szegmensfájlok a memóriában.
Ezek tényleges fájlból olvasott adatokat is tartalmazhatnak, vagy szegmensek és sziták ellenőrzésekor a Java program is generálja.
Ezzel az osztállyal szegmensfájlt csak olvasni lehet, írni nem.

Egy szegmens összesítését a Segment.aggregate() függvény végzi.
Az eredményül kapott Aggregate példány az adatbázis formátumánál leírt szegmensstatisztika tükre.
Az összesítőfájlt az AggregatesReader és AggregatesWriter osztállyal lehet írni és olvasni, mindkét esetben a szegmensek szigorúan növekedő kezdőszámú sorrendben dolgozhatóak fel.
A írás és az olvasás AggregateBlock példányokkal dolgozik, ezek az objektumok a statisztikához való hozzáférés mellett a betömörített bináris adatot jegyzik meg, hogy a statisztika változatlan kiírása esetén ki lehessen hagyni az időigényes betömörítést.

Az szegmensenkénti statisztikák alapján a megjelenítésre szánt mintákat az Aggregates osztály készíti el.
A szegmenseket az összesítésfájl sorrendjében dolgozza fel, az első hiányzó szegmensig. A megjelenített statisztikák legtöbbje egyszerűen összesíthető a szegmensenkénti adatokból. A prímhézagok esetében a szegmenseken átívelő hézag külön odafigyelést igényelnek.

Ez a csomag tartalmazza a CSV fájlok olvasásához és írásához a CSVReader és CSVWriter osztályokat. Mindkettő stream alapon teszi lehetővé a szöveges cellák soronkénti feldolgozását.

\subsubsection{gui.sieve}

Ebben a csomagban, és a gui.sieve.eratosthenes alcsomagjában, a futási idők méréséhez implementált sziták vannak.

\begin{tikzpicture}

\umlclass[x=0.5, y=0, type=abstract]{OperationCounter}{}{
+add() \\
+get()::long \\
+increment() \\
+reset()}

\umlclass[x=5.5, y=-0.3, type=abstract]{SieveTable}{}
{+clear(prime) \\
+flip(number) \\
+isPrime(number)::boolean \\
+setComposite(number) \\
+setPrime(number)}

\umlclass[x=10, y=1]{LongTable}{}{}
\umlclass[x=10, y=-1]{Segment}{}{}
\umlclass[x=0, y=-4, type=abstract]{Sieve}{}{+reset(start) \\ +sieve()}
\umlclass[x=0, y=-7, type=abstract]{SegmentedSieve}{}{}
\umlclass[x=0, y=-9.5, type=abstract]{EratosthenesianSieve}{}{}
\umlclass[x=4, y=-4]{TrialDivision}{}{}
\umlclass[x=4, y=-6]{SieveOfAtkin}{}{}
\umlclass[x=9, y=-6]{SieveOfEratosthenes}{}{}
\umlclass[x=8, y=-8]{QueueSieve}{}{}
\umlclass[x=7, y=-10]{CacheOptimizedLinearSieve}{}{}
\umlclass[x=5, y=-12]{SimpleBucketSieve}{}{}
\umlclass[x=1, y=-12, type=abstract]{BucketSieve}{}{}
\umlclass[x=1, y=-14]{Bucket1Sieve}{}{}
\umlclass[x=5, y=-14]{BucketNSieve}{}{}

\umlinherit{LongTable}{SieveTable}
\umlinherit{Segment}{SieveTable}
\umluniassoc{Sieve}{SieveTable}
\umluniassoc{Sieve}{OperationCounter}
\umlinherit{SegmentedSieve}{Sieve}
\umlinherit{TrialDivision}{Sieve}
\umlinherit{EratosthenesianSieve}{SegmentedSieve}
\umlinherit{SieveOfAtkin}{SegmentedSieve}
\umlinherit{BucketSieve}{EratosthenesianSieve}
\umlinherit{SieveOfEratosthenes}{EratosthenesianSieve}
\umlinherit{QueueSieve}{EratosthenesianSieve}
\umlinherit{CacheOptimizedLinearSieve}{EratosthenesianSieve}
\umlinherit{SimpleBucketSieve}{EratosthenesianSieve}
\umlinherit{Bucket1Sieve}{BucketSieve}
\umlinherit{BucketNSieve}{BucketSieve}
\end{tikzpicture}

A szitál a Sieve osztály leszármazottai.
A példányaitól elvárás, hogy
\begin{itemize}
\item a szitálást szegmensenként végezzék
\item a szitatábla bitvektorát csak korlátozottan éri el
\begin{itemize}
\item csak az éppen szitált szegmensbe eső számokat éri el
\item páros számot sose ér el
\item legfeljebb $2^{32}-1$-ig olvassa vissza a szitálás eredményét
\end{itemize}
\item a szegmens mérete szabályozható, a lehetséges értékek a kettő hatványai $2^8$-tól $2^{30}$-ig 
\item bármikor újra lehessen inicializálni a szitát egy szegmens kezdetéhez úgy, hogy onnantól már további felkészülési idő nélkül több egymás utáni szegmenst tud szitálni
\item az OperationCounter osztály segítségével számon tartja a szitálás műveletigényét.
\end{itemize}

A SieveTable osztály Segment implementációja az adatbázisnál is használt szegmensfájl, szita ellenőrzésekor ez a szitatábla tárolja a bitvektort, és az ellenőrzés a végeredményt hasonlítja össze a referenciaszita eredményével.
A LongTable megvalósítást a program a futási idő mérésénél használja, ez a szitatábla mindig $2^{32}$-ig tartja nyilván az eredményt, annál nagyobb számoknál a műveletet elvégzi a memóriában, de különböző számok ugyanazt a bitet módosíthatják, így egy számra vonatkozó eredmény nem olvasható vissza.

Mindegyik szita megvalósítása valamilyen formában eltárolja a már megtalált prímeket, de csak a szitált szegmens végének négyzetgyökéig veszik azokat figyelembe.
A sziták a prímek és pozíciójuk tárolását, egy kivételével, egy vagy két PrimitiveList használatával oldják meg, az elemek csoportosítását a listán belüli helyük adja.
Az edénysoron alapuló sziták belső edényeinek pillanatnyi mérete tág határok között mozog, azért a memóriaveszteség csökkentésére ezek ez edények kisebb, fix méretű edények láncolt listái.
Az edénysor ezeket a listaelemeket feldolgozás után újrahasznosítja a szemétgyűjtés elkerüléséhez.

A CacheOptimizedLinearSieve belső adatstruktúrája nehezebben bővíthető, mint a listás vagy elsőbbségi soros szitáké.
Ezért a COLS szita $2^{32}$-ig egy egyszerű listás eratoszthenészi szitaként viselkedik, és az azutáni első szegmens szitálásakor alakítja ki a prímek csoportosítását.

A sziták egyszerű hierarchiát alkotnak.
A SegmentedSieve leszármazottai minden prímmel csak egyszer foglalkoznak egy szegmensben, bár lehet, hogy az több helyen szitál.
Az EratosthenesianSieve típusú sziták a prímekkel úgy szitálnak, hogy a prím eltárolt utolsó többszörösét a prím kétszeresével növelik, amíg a többszörös a szegmensbe esik.

A sziták algoritmusai a ''Sziták'' fejezetben vannak részletesebben kifejtve.
Az implementációk főbb jellemzői:
\begin{itemize}
\item TrialDivision: próbaosztás
\item SieveOfAtkin: Atkin szitája
\item Eratoszthenész szitájának implementációi, mindegyik a prím-pozíció párok eltárolásával próbálja gyorsítani a futását
\begin{itemize}
\item SieveOfEratosthenes: a prímeket egy tömbben tárolja, és minden szegmens szitálásához minden prímmel próbál szitálni a szegmensben
\item QueueSieve: a prímeket bináris kupacban tárolja, szitáláskor a kupac elejét dolgozza fel, amíg az a szegmensbe esik.
\item CacheOptimizedLinearSieve: a prímeket kétszintű edényrendszerbe csoportosítja, szitáláskor a szegmensbe eső elemek már edényekbe vannak válogatva, azokat csak be kell járni
\item SimpleBucketSieve: a prímeket a QueueSieve-hez hasonlóan egy elsőbbségi sorban tartja nyilván, az elsőbbségi sor egyre nagyobb intervallumokat lefedő edények listája
\item Bucket1Sieve: az edénysoron alapuló szita felgyorsítása a COLS 0. ''körével'', a szegmensek méreténél kisebb prímeket a sortól külön, egy tömbben tárolja. Ezek a kis prímek minden szegmensben szitálnak, felesleges lenne a sorból minden szegmensnél kivenni, majd visszahelyezni.
\item BucketNSieve: a Bucket1Sieve további optimalizálása, az edénysor számrendszerének alapját megnövelve a prímek részleges rendezését finomítja.
\end{itemize}
\end{itemize}

\subsubsection{gui.ui}

\subsubsection{Parancssor}

A gui program legtöbb művelete parancssorból is indítható.
A parancssori műveletek a gui.Command.Descriptor osztály példányaival írhatóak le, és a gui.Main.main() a program indítási paramétereit ezekkel a leírókkal összevetve választja ki a futtatandó parancsot.
A leíró a parancs belépési pontja mellett a megengedd argumentumok listáját tartalmazza. A parancs kiválasztásához a tényleges és elvárt argumentumok meg kell egyezzenek.
Az argumentum leírása reguláris kifejezéssel szintaktikailag ellenőrzi a tényleges argumentumokat, a szemantikai helyesség ellenőrzése minden parancs saját feladata.

\subsubsection{Adatbázis műveletek}

\subsubsection{Szegmensek ellenőrzése}

\subsubsection{Sziták ellenőrzése}

\subsubsection{Grafikon ábrázolása}

A grafikonrajzolónak sokkal okosabbnak kéne lennie, hogy gyorsan változó függvényeket
helyesen jelenítsen meg, reménytelenül okosnak.

\section{Sziták}

Eratosztenész szitája, szegmentáltan is. COLS. Prioritásos sorral. Atkin szitája.

Szegmentált szita inicializálása.

Trial division. Pszeudoprím teszt.

Feltételek. Elméleti sebesség.

\section{Prioritásos sorok}

\begin{algorithmic}[1]
\State $q \gets$ \Call{Új-sor}{}
\For{$i\gets 2, n$}
	\While{$\exists (p, k) \in q: k \le i$}
		\State $(p, k) \gets $ \Call{Sor-Eltávolít-Min}{q}
		\State \Call{Megjelöl}{i}
		\State \Call{Sor-Beszúr}{q, (p, k+p)}
	\EndWhile
	\If{$\neg$ \Call{Megjelölt?}{i}}
		\State \Call{Sor-Beszúr}{q, (i, 2i)}
	\EndIf
\EndFor
\end{algorithmic}

\subsection{Bináris kupac}

A mérések grafikonják pixelei alapján lassú. A beszúrásonkénti elméleti
$\mathcal{O}(log_{}{|q|})$ ideje se biztató.

\subsection{Bigyó} %%% EMIL: Ettől SOKKAL jobb nevet kell találni neki!!!!

A bigyó egy monoton prioritásos sor.
A sor monoton, minden állapotához tartozik egy érték, a sor aktuális pozíciója,
aminél kisebb vagy egyenlő pozíciójú értéket a sor nem tartalmazhat.
A bigyó edények egy végtelen sorozatát is tárolja, a sor elemei ezekbe az edényekbe kerülnek.
Egy eltárolt elem helyét a sorozatban az elem pozíciójának
és a sor aktuális pozíciójának távolsága határozza meg.

A távolságfüggvény legyen

\begin{align*}
d(x, y) := \lfloor log_{2}{}(x \oplus y) \rfloor & & (x, y \in \mathbb{N}, y > x \ge 0)
\end{align*}

ahol $\oplus$ a bitenkénti XOR.

$d(x, y)$ a legnagyobb bit-index, ahol $x$ és $y$ eltér.

Ha $q$ egy bigyó, legyen $q.a$ $q$ aktuális pozíciója, és $q.e[i]$ $q$ $i$. edénye. AZ edények, és a számpárok struktúrája...

Egy q bigyó invariánsa
\begin{align*}
\forall (p, k) \in q &: &\\ 
	& q.a < k\\
	& \forall i \in \mathbb{N}_{0}: (p, k) \in q.e[i] \iff i=d(q.a, k) \\
\forall (p, k) \not\in q &: \forall i \in \mathbb{N}_{0}: (p, k) \not\in q.e[i]
\end{align*}

Új, üres sor létrehozása tetszőleges kezdőpozíciótól, és meglévő sorba elem beszúrása...

A sor elemeinek feldolgozása $i$-ig
\begin{algorithmic}[1]
\While{$q.a < i$}
	\State $j \gets d(q.a, q.a + 1)$
	\State $q.a \gets q.a + 1$
	\ForAll{$(p, k) \in q.e[j]$}
		\State \Call{Edény-Kivesz}{$q.e[j], (p, k)$}
		\If{$k = i$}
			\State \Call{Visszaad}{$(p, k)$}
		\Else
			\State \Call{Edény-Beszúr}{$d(q.a, k), (p, k)$}
		\EndIf
	\EndFor
\EndWhile
\end{algorithmic}

\subsubsection{Helyesség}

\subsubsection{Idő}

\subsubsection{Hely}

\subsubsection{Számrendszer}

És számrendszer vs. tisztán funkcionálisban nincs bármekkora tömb, csak valami fával közelítve.

Amúgy sincs bármekkora tömb...

És exponenciálisan kell növelni...

\subsubsection{Cache}

És exponenciálisan kell növelni...

\section{Memória}

Összes prím, és pozíciója $2^32$-ig. Primitív típusok és boxing. Garbage collector.

\section{Teszt}

\subsection{Adatszerkezetek}

\subsection{Numerikus pontosság és sebesség}

\subsection{Sziták}

\subsection{Elmélet vs. mért}

\documentclass[12pt]{report}
\usepackage[a4paper,
			inner = 35mm,
			outer = 25mm,
			top = 25mm,
			bottom = 25mm]{geometry}
\usepackage{lmodern}
\usepackage[magyar]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[unicode]{hyperref}
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{epstopdf}
\usepackage{setspace}
\usepackage[nottoc,numbib]{tocbibind}
\usepackage{color}
\setcounter{secnumdepth}{3}
\usepackage{algpseudocode}
\usepackage{listings}
\usepackage{titlesec}
\onehalfspacing
\lstset{literate=
  {á}{{\'a}}1 {é}{{\'e}}1 {í}{{\'i}}1 {ó}{{\'o}}1 {ú}{{\'u}}1
  {Á}{{\'A}}1 {É}{{\'E}}1 {Í}{{\'I}}1 {Ó}{{\'O}}1 {Ú}{{\'U}}1
  {à}{{\`a}}1 {è}{{\`e}}1 {ì}{{\`i}}1 {ò}{{\`o}}1 {ù}{{\`u}}1
  {À}{{\`A}}1 {È}{{\'E}}1 {Ì}{{\`I}}1 {Ò}{{\`O}}1 {Ù}{{\`U}}1
  {ä}{{\"a}}1 {ë}{{\"e}}1 {ï}{{\"i}}1 {ö}{{\"o}}1 {ü}{{\"u}}1
  {Ä}{{\"A}}1 {Ë}{{\"E}}1 {Ï}{{\"I}}1 {Ö}{{\"O}}1 {Ü}{{\"U}}1
  {â}{{\^a}}1 {ê}{{\^e}}1 {î}{{\^i}}1 {ô}{{\^o}}1 {û}{{\^u}}1
  {Â}{{\^A}}1 {Ê}{{\^E}}1 {Î}{{\^I}}1 {Ô}{{\^O}}1 {Û}{{\^U}}1
  {œ}{{\oe}}1 {Œ}{{\OE}}1 {æ}{{\ae}}1 {Æ}{{\AE}}1 {ß}{{\ss}}1
  {ű}{{\H{u}}}1 {Ű}{{\H{U}}}1 {ő}{{\H{o}}}1 {Ő}{{\H{O}}}1
  {ç}{{\c c}}1 {Ç}{{\c C}}1 {ø}{{\o}}1 {å}{{\r a}}1 {Å}{{\r A}}1
  {€}{{\euro}}1 {£}{{\pounds}}1 {«}{{\guillemotleft}}1
  {»}{{\guillemotright}}1 {ñ}{{\~n}}1 {Ñ}{{\~N}}1 {¿}{{?`}}1
}
\begin{document}
\begin{titlepage}
\vspace*{0cm}
\centering
\begin{tabular}{cp{2cm}c}
\begin{minipage}{4cm}
\vspace{0pt}
\includegraphics[width=1\textwidth]{eltecimerszines}
\end{minipage} & &
\begin{minipage}{7cm}
\vspace{0pt}Eötvös Loránd Tudományegyetem \vspace{10pt} \newline
Informatikai Kar \vspace{10pt} \newline
Komputeralgebra Tanszék
\end{minipage}
\end{tabular}

\vspace*{0.2cm}
\rule{\textwidth}{1pt}

\vspace*{6cm}
{\Huge Prímszita algoritmusok összehasonlítása}

\vspace*{5cm}
\begin{tabular}{lp{3cm}l}
Vatai Emil & & Nagy Péter\\
Adjunktus & & Programtervező Informatikus BSc
\end{tabular}

\vfill

\vspace*{1cm}
Budapest, 2018
\end{titlepage}

\tableofcontents

\chapter{Bevezetés}

{\color{red}
Sziták összehasonlítása azonos környezetben.
Hatékonyság összehasonlítása az elmélet szerint várható értékekkel.
Ellenőrzésként a prímek néhány statisztikájának összevetése az elméleti értékekkel,
és az ismert eredményekkel.
Hatékonyság és implementálhatóság.
}

%%% EMIL: Ötlet/javaslat: szétszedni kisebb fájlokba a dolgot include-okkal.
\chapter{Felhasználói dokumentáció}

\section{A megoldott feladat}

A program lehetővé teszi a prímek néhány statisztikájának ábrázolását grafikonon,
és összevetését elméleti becsült értékekkel, valamint néhány különböző szita-algoritmus
futási idejének megmérését, és grafikus megjelenítését.
A programmal egyéb forrásból származó minták megjelenítése is lehetséges.

A prímszámok statisztikáinak előállításához a programhoz tartozik egy optimalizált
szita-implementáció, amivel $2^{64}$-ig lehet szitálni, és az eredményt rögzíteni.
Az elmentett prímlistákat a program egy külön része összesíti több statisztika szerint,
és a megjelenítést az összesítések alapján végzi el.

Különböző szita-algoritmusok futási idejének összehasonlításához a program tartalmazza
Atkin\cite{atkin} szitájának egy implementációját,
és Eratoszthenész szitájának néhány variációját.

\section{Felhasznált módszerek}

A program két elkülönülő részből áll. A prímszámok statisztikáinak
előállításához először szükséges a prímek listájának előállítása.
Ehhez egy optimalizált, gyors szita C nyelven készült el.
A könnyebb implementálhatóság miatt ez is két külön program, a kis
számokat szitáló init, és a nagyobb számokkal dolgozó generator.
A két program a működési elvében hasonló.

A program többi része Java nyelven van megírva, ez a gui nevű program.
Ez összesíti a prímek listáját, tartalmazza a futási idők összehasonlításához
írt szitákat, és jeleníti meg a prímek statisztikáit, és a futási idők
mintáit.

\subsection{Init és generator program}

A prímszámok listájának generátora C nyelven készült el.
A program csak parancssorból futtatható, és a sztenderd könyvtári függvényekből
is csak néhányat használ a memóriájában előállított eredmények fájlba írásához.
A C nyelv választását a hatékony végrehajtás és memóriafelhasználás, és
a hordozhatóság indokolja, a generátor elkülönítését az automatizálhatóság indokolja.

A prímgenerátor Eratoszthenész szitájának szegmentált változata,
a szitatábla egy $2^{30}$ hosszú darabját szitálja ki minden iterációban.
A generátor önmaga is két részből áll.
Egy egyszerűbb implementáció a prímek listáját $2^{32}$-ig állítja elő.
Ez az első 4 szegmens nem csak a statisztikákhoz szükséges,
a generator, és a Java program szitái is használja,
amikor a szitálás intervalluma 1-nél nagyobb számtól kezdődik.

A gyorsabb, de összetettebb szita $2^{32}$-től $2^{64}-2^{34}$-ig szitál,
és a futásához szükséges a prímek listája $2^{32}$-ig.
A szitatáblát a memóriában a gyorsítótár hatékonyabb a kihasználásához kisebb
részszegmensekre osztja,
és a prímeket a nagyságuk és a következő szitálási pozíciójuk szerint csoportosítja.
Továbbá nagyobb prímeknek csak harminccal relatív prím többszöröseit veszi figyelembe.

\subsection{Gui}

A program többi része a Java környezethez készült.
A minták és függvények ábrázolásához használt Swing grafikus könyvtár
a Java környezet része, egyszerű, hordozható, támogatja az élsimítást,
és a sebessége elfogadható a feladatra.
A Java sztenderd konténerosztályai habár kényelmesen használhatóak, és változatosak,
de sebesség és memóriakihasználtsági problémák miatt több helyen is alacsonyabb szintű
megoldást kellett választani.  %%% EMIL: Most kezdek azon morfondírozni hogy itt sokat írsz a fejlesztői döntésekről és keveset a program felhasználásáról. Ezt majd érdemes lesz figyelembe venni.
%%% EMIL: Itt ha gondolod inkább ilyen Gauss és hasonló prímek eloszlására vonatkozó rizsát lehet írni és valahogy összekötni azzal hogy mit old meg a program (ahelyett hogy leírod hogy HOGYAN oldja meg ezeket)

A program a mintákat alapfüggvények lineáris kombinációjával képes közelíteni,
a legkisebb négyzetek módszerével. A minták elemeinek nagy száma, és a mintaértékek
nagy terjedelme miatt szükséges volt a numerikus algoritmusok nagyobb pontosságú
implementációja, ami a számítási idő növekedésével jár.

A program hosszabb távon egyedül a prímek szegmensenkénti statisztikáit tárolja,
amit csak sorban dolgoz fel, és a statisztikák összmérete sem indokolna
egy egyszerű bináris fájlnál bonyolultabb megoldást. Az adatvesztés elkerüléséhez
elég a statisztikafájl csere alapú felülírása.

A Java program tartalmaz több prímszita implementációt is, ezeknek az algoritmikus
bonyolultsága különböző, de a futási idejük összehasonlíthatóságához a közös részek közös
implementációt kaptak, és az eltérő részek hasonló szinten optimalizáltak.
A sziták helyességének ellenőrzéséhez a sziták eredménye egymással összehasonlítható.

A programhoz elkészült Eratoszthenész szitájának több variációja.
A legegyszerűbb szegmentált változata a szitálandó intervallumot kisebb
részintervallumokra bontja, ezeket sorban szitálja úgy, hogy minden szegmensben megjelöli az összes prím abba a szegmensbe eső többszörösét.

A többi implementált eratoszthenészi szita
ezen az algoritmuson javít azzal, hogy
csak az éppen szitált szegmensben szitáló prímekkel foglalkoznak.
A prioritásos soron alapuló sziták a prímeket részlegesen
rendezik az alapján, hogy hány szegmensnyire van az éppen szitált szegmenstől a prím következő többszöröse,
a sor elejéről eltávolítják a szegmensben szitáló
prímeket, és az új pozíciójukkal a sorba visszahelyezik.
Ilyen a bináris kupacot, és az edénysort használó szita.

A {\color{red}cache optimized linear sieve}\cite{cols}
a prímeket teljesen rendezi az alapján, hogy legközelebb
melyik szegmensben fognak szitálni,
és a prímek nagyság szerinti csoportosításával
a rendezés fenntartásához az elemek memóriabeli
mozgatását is kerüli.

Atkin szitája\cite{atkin} az előbbi algoritmusoktól
jelentősen eltér. Eratoszthenész szitája
egy $n$ számról úgy dönti el, hogy prím-e,
hogy az $n=pq$ egyenlet próbálja megoldani
$p$ és $q$ szisztematikus bejárásával,
ahol $p<n$ prím, és $q$ egész.
Atkin szitája az $n=ax^2+by^2$ egyenlet megoldásait
keresi, $x$ és $y$ pozitív egészek befutásával,
$a$ és $b$ egész konstansok.
A kvadratikus formát és $x$ és $y$ lehetséges értékeit
Atkin az egészek algebrai bővítésével
határozza meg,
$n \in 4\mathbb{Z}+1$ esetén a Gauss-egészek,
$n \in 6\mathbb{Z}+1$ esetén az Eisenstein-egészek,
és $n \in 12\mathbb{Z}+11$ esetén a $\mathbb{Z}[\sqrt{3}]$
segítségével.

A sziták között kapott helyet a próbaosztás, és az erős pszeudo-prím teszt is,
de ezek a lassúságuk miatt csak igen rövid tartományokon használhatóak. Egy prímszita számok egy listájáról
dönti el, hogy melyik prím, és melyik összetett.
A próbaosztás egy faktorizációs eljárás,
ami egyetlen számot nem-triviális szorzatra
próbál bontani. Az (erős) pszeudoprím teszt
egy prímteszt, egyetlen számról próbálja eldönteni,
hogy az prím-e. A prímteszteket általában
több nagyságrenddel nagyobb számokra alkalmazzák,
mint a szitákat, és teljes módszer helyett
sokszor megelégednek egy valószínűségi válasszal.

\section{A program telepítése és futtatása}

A program futtatásához Windows vagy Linux operációs rendszer szükséges,
legalább 4GB szabad memóriával.
A Java program futtatásához JRE8 szükséges, a fordításához JDK8.
A C program fordításához C99 szabványú fordítóprogram kell.  A program fejlesztése és tesztelése OpenJDK8-cal és GCC 7.3-mal történt
Linux operációs rendszeren.

%%% EMIL: A másik dolog amit támogatok hogy beírod a github repo url-jét is.
A CD mellékleten található tarball a Java programot lefordítva is tartalmazza,
kicsomagolás után azonnal futtatható.
A C programot a generator könyvtárban található Makefile segítségével lehet lefordítani:
\begin{lstlisting}[basicstyle=\tiny,language=bash]
generator$ make clean build
\end{lstlisting}

%%% EMIL: Ez a szöveg is a \tiny{..}ban van, és furcsák a sortávolságok.  A listings bash beállításait érdemes piszkálni, hogy automatikusan azt csinálja amit szeretnél. https://tex.stackexchange.com/questions/180222/how-to-change-font-size-for-specific-lstlisting

A Java program a NetBeans 8-as verziójával készült,
parancssorból a project ant fájlának segítségével lehet
újrafordítani:
\begin{lstlisting}[basicstyle=\tiny,language=bash]
gui$ ant clean jar
\end{lstlisting}

A program futtatásához több előkészített script is rendelkezésre áll,
ezeket mind a scripts könyvtárból lehet indítani.
Az előző két fordítást egyben is el lehet végezni a recompile scripttel:
\begin{lstlisting}[basicstyle=\tiny,language=bash]
scripts$ ./recompile
\end{lstlisting}

\section{Prímek keresése}

A prímek keresését két program végzi, az init program
$2^{32}$-ig keresi meg és tárolja el a prímeket,
a generator $2^{32}$-től $2^{64}-2^{43}$-ig.
Az init készítette szitattáblák a generator futásához szükségesek.

Mindkét program a számokat $2^{30}$ hosszú táblánkként szitálja,
minden tábla első száma $2^{30}k+1$ alakú.
A szitatáblában csak a páratlan számok vannak nyilvántartva.
A szitatáblákat a programok a
fájlrendszerben bitvektorként tárolják, egy tábla kb. $64$Mb.

Az első négymilliárd szám szitálása a következő képpen indítható el:

\begin{lstlisting}[basicstyle=\tiny,language=bash]
generator$ ./init.bin ../db
szegmens 0 - kezdet             1 - felkészülés 159 906 063 ns - szitálás 1 122 878 403 ns
szegmens 1 - kezdet 1 073 741 825 - felkészülés   2 353 698 ns - szitálás 1 171 101 336 ns
szegmens 2 - kezdet 2 147 483 649 - felkészülés   2 344 515 ns - szitálás 1 188 330 478 ns
szegmens 3 - kezdet 3 221 225 473 - felkészülés   2 391 660 ns - szitálás 1 199 900 603 ns
\end{lstlisting}
Ennek eredmény 4 bittérképfájl, amit a db mappába ment.

A generator programot több féle képpen is lehet indítani.
Mindegyik esetben két paramétert kell megadni az indításhoz,
a számot, ahol szitálást kezdje, és a szegmensek számát, amit
ebben a futásban végig kell szitálni.
A kezdő számot meg lehet adni decimálisan is, vagy hexadecimálisan is,
"0x" prefixszel. A szegmensek számát is kétféle képpen lehet szabályozni.
Az egyik lehetőség fix számú szegmens megadása, decimálisan, vagy hexadecimálisan.

\begin{lstlisting}[basicstyle=\tiny,language=bash]
generator$ ./generator.bin ../db start 0x100000001 segments 3
szegmens kezdet: 4 294 967 297
szegmensek száma: 3
kis szegmensek mérete: 22
elágazások bitjei: 8
felkészülés 1/4
felkészülés 2/4
felkészülés 3/4
felkészülés 4/4
felkészülés vége
szegmens 4 - kezdet 4 294 967 297 - felkészülés 8 162 031 487 ns - szitálás 729 914 370 ns
szegmens 5 - kezdet 5 368 709 121 - felkészülés           418 ns - szitálás 736 412 117 ns
szegmens 6 - kezdet 6 442 450 945 - felkészülés           385 ns - szitálás 750 022 409 ns
összes szitálás 2 216 348 896 ns
\end{lstlisting}

A másik mód a háttértáron fenntartandó szabad hely átadása, decimálisan,
vagy "0x" prefixszel hexadecimálisan. Ekkor következő szegmens szitálása előtt
megvizsgálja, hogy van-e még annyi szabad hely az adatbáziskönyvtárban, mint
amennyi meg van adva, ha igen, akkor szitálja a szegmenst,
és lép a következőre,
és ha nincs már elég szabad hely, akkor a program megáll.

\begin{lstlisting}[basicstyle=\tiny,language=bash]
generator$ ./generator.bin ../db start 0x100000001 reserve-space 1000000000
szegmens kezdet: 4 294 967 297
fenntartandó hely: 1 000 000 000 byte 
kis szegmensek mérete: 22
elágazások bitjei: 8
felkészülés 1/4
felkészülés 2/4
felkészülés 3/4
felkészülés 4/4
felkészülés vége
szegmens 4 - kezdet 4 294 967 297 - felkészülés 8 162 031 487 ns - szitálás 729 914 370 ns
szegmens 5 - kezdet 5 368 709 121 - felkészülés           418 ns - szitálás 736 412 117 ns
szegmens 6 - kezdet 6 442 450 945 - felkészülés           385 ns - szitálás 750 022 409 ns
összes szitálás 2 216 348 896 ns
\end{lstlisting}

Mindkét program kimenetében a start a szegmens kezdőszáma, a segment az indexe,
$start=segment \cdot 2^{30}+1$, az init a szita inicializálási ideje a szitálás előtt,
és a sieve a szegmens szitálásának ideje. Ezek az információk az elmentett
táblafájlokból is kiolvashatóak.

\section{Mintaadatbázis karbantartása}

A mintaadatbázis a lementett szitatáblák összesített statisztikáit tárolja.
A programok az adatbázis könyvtárában kétfajta fájlt vesznek figyelembe.
A ''primes\textbackslash.[0-9a-f]\{16\}'' reguláris kifejezésnek megfelelő nevű  %%% EMIL: \fonttt{...} parancsot ismered?
fájlok a szegmensek szitatáblái.
A fájlnév második fele a szegmens kezdőszáma hexadecimálisan.
A fájl a páratlan számok bittérképe mellett tartalmazza a szegmens
szitálásának megkezdésére, és a szitálására fordított időt,
valamint ellenőrzésképpen a szegmens kezdőszámát is.

A szitatáblák mellett az adatbázis tartalmazhatja szegmensek összesített
statisztikáit is, ''aggregates'' néven. Ez a fájl az eddig összesített
szegmensekről a következő információkat tartja nyilván,
minden szegmensről külön-külön:
\begin{itemize}
\item a szegmens kezdőszáma
\item a szegmens szitálására való felkészülés idejét
\item a szegmens szitálásának idejét
\item az összesítésre fordított időt
\item a szegmensfájl utolsó módosítási idejét
\item a szegmensbe eső legkisebb, és legnagyobb prímet
\item a szegmensbe eső prímek számát,
$12\mathbb{Z}+11$, $4\mathbb{Z}+1$, $4\mathbb{Z}+3$, $6\mathbb{Z}+1$ alakok szerinti bontásban
\item a szegmensben előforduló prímhézagok első előfordulásának helyét,
és az előfordulások számát.
\end{itemize}

Példaként ha a szegmensek mérete 16 szám lenne,
és 17-től szitálnánk egy szegmens, akkor a szegmensfájl
leírná, hogy a prímek 17, 19, 23, 29, 31,
és az összetett számok 15, 21, 25, 27.
A szegmens összesítése
\begin{itemize}
\item a szegmens 17-tel kezdődik
\item a legkisebb prím 17, a legnagyobb 31
\item a szegmensben 5 darab prím van,
	ebből 2db $4\mathbb{Z}+1$,
	3db $4\mathbb{Z}+3$, 2db $6\mathbb{Z}+1$,
	és 1db $12\mathbb{Z}+11$ alakú
\item a szegmensben előforduló prímhézagok
\begin{itemize}
\item 2 (ikerprímek) kétszer fordul elő, először 17-nél
\item 4 egyszer fordul elő, először 19-nél
\item 6 egyszer fordul elő, először 23-nál
\end{itemize}
\end{itemize}
lenne.

Az adatbázison három művelet végezhető:
\begin{itemize}

\item Le lehet kérni, hogy
\begin{itemize}
\item a szegmensfájlok száma
\item az első és utolsó szegmensfájl
\item az legkisebb hiányzó szegmensfájl
\item a szegmensstatisztikák száma
\item az első és utolsó szegmensstatisztika
\item az legkisebb hiányzó szegmensstatisztika
\item van-e szegmensfájl, ami nincs összesítve
\end{itemize}

\item Összesíteni lehet az új szegmensfájlokat.

\item Össze lehet fésülni két összesítőfájlt.

\end{itemize}

Mindhárom művelet elvégezhető grafikus felületen, és automatizáláshoz parancssorból is.
A grafikus felületet a gui scripttel lehet indítani, a parancssorból
a database script segítségével lehet elérni a műveleteket.

Ezek a scriptek határozzák meg, hogy a program melyik könyvtárat használja
adatbázisként, ezt nem kell külön megadni.
Szükség esetén ez a könyvtár a scriptek egyszerű módosításával
megváltoztatható.

\subsection{Adatbázis információk}

A adatbázis információkat a grafikus felületen a ''DB info'' gomb megnyomásával lehet
lekérdezni, parancssorból a ''database info'' kiadásával.

\begin{lstlisting}[basicstyle=\tiny,language=bash]
scripts$ ./database info
100.0%
szegmensfájlok: szegmensek száma: 7
szegmensfájlok: első szegmens kezdete: 1
szegmensfájlok: utolsó szegmens kezdete: 6,442,450,945
szegmensfájlok: első hiányzó szegmens kezdete: 7,516,192,769
szegmensfájlok: hiányzó szegmensek száma: 18,446,744,073,709,551,593

összesítések: szegmensek száma: 62,881
összesítések: első szegmens kezdete: 1
összesítések: utolsó szegmens kezdete: 67,516,885,893,121
összesítések: első hiányzó szegmens kezdete: 67,517,959,634,945
összesítések: hiányzó szegmensek száma: 18,446,744,073,709,488,719

új szegmensfájlok: 7

scripts$ ./database info crunch 100
100.0%
szegmensfájlok: szegmensek száma: 7
szegmensfájlok: első szegmens kezdete: 1
szegmensfájlok: utolsó szegmens kezdete: 6,442,450,945
szegmensfájlok: első hiányzó szegmens kezdete: 7,516,192,769
szegmensfájlok: hiányzó szegmensek száma: 18,446,744,073,709,551,593

összesítések: szegmensek száma: 62,881
összesítések: első szegmens kezdete: 1
összesítések: utolsó szegmens kezdete: 67,516,885,893,121
összesítések: első hiányzó szegmens kezdete: 67,517,959,634,945
összesítések: hiányzó szegmensek száma: 18,446,744,073,709,488,719

crunch: ../generator/generator.bin ../db start 0x3d6840000001 segments 0x64
\end{lstlisting}

A ''crunch'' utótag és szitálni kívánt szegmensek számának megadásával az utolsó sorban
a következő futtatásra ajánlott parancsot is megjeleníti a program.
Ezeknek a parancsoknak a követésével a teljes szitálható tartományt fel lehetne dolgozni.
A ''crunch-numbers'' script ezt a feladatot kísérli meg elvégezni.

Az info megjeleníti az új szegmensfájlok számát is, azokat,
amikhez vagy nem tartozik összesített adat, vagy tartozik,
de az ott tárolt utolsó módosításnál újabb a szegmensfájl.

\subsection{Szegmensek összesítése}

Az adatbázis könyvtárban
található új szegmensfájlokat a ''DB összesítés'' gomb megnyomásával,
vagy a ''database reaggregate'' paranccsal lehet összesíteni.
Minden olyan szegmensfájlról új összesítés készül,
amihez még nem tartozott összesítés, vagy a szegmensfájl
újabb, mint ami alapján a már meglévő összesítés készült.
Az adatbázisban már meglévő, többi szegmenshez tartozó statisztika nem vész el.

\begin{lstlisting}[basicstyle=\tiny,language=bash]
scripts$ ./database reaggregate
100.0%
\end{lstlisting}

\subsection{Összesítőfájlok összefésülése}

Lehetőség van egy másik adatbázisból statisztikák átvételére is.
Erre több gépen párhuzamosan szitálva lehet szükség.
Az összefésülést a grafikus felületen a ''DB import'' megnyomása után
egy file kiválasztásával lehet indítani, parancssorból a ''dabatase import aggregates fájlnév''
kiadásával. A megadott fájlból azokat a szegmeneseket veszi át a program,
amik vagy nincsenek még meg az adatbázisban, vagy megvannak, de az importált
statisztikák utolsó módosítási ideje nagyobb az adatbázisban lévőnél.

\begin{lstlisting}[basicstyle=\tiny,language=bash]
scripts$ ./database import aggregates ../db/aggregates.large
100.0%
\end{lstlisting}

{\color{red}screenshot}
%%% EMIL: ezt a részt kicst kuszának tartom. Én személy szerint, lehet úgy csinálnam, pl (feltéve hogy már rendesen bevezetted a generátor, init, stb programokat), és akkor először felsorolnám a műveleteket, hogy egy-egy program milyen parancsokat tud, aztán meg külön külön leírnám azok működését. Valahogy "nem elég száraz" a szöveg, egymásba folynak a mondatok... és szerintem itt most épp egy kicsit szárazabb, szakmaibb leírás kellene.

\section{Szitatáblák ellenőrzése}

A generator program teszteléséhez a grafikus program képes a szegmensfájlok
ellenőrzésére.
Ehhez a program újra előállítja az ellenőrzött szegmensfájlokat,
és azokat összeveti. A újraelőállításhoz egy egyszerű szegmentált
Eratoszthenészi szitát, vagy ez erős pszeudo-prím tesztet lehet választani.
A pszeudo-prím teszt rendkívül lassú, a célja, hogy a szitákhoz képest egy
alapvetően más módszer is rendelkezésre álljon az ellenőrzéshez.

A grafikus felületen a "Szegmensfájlok ellenőrzése" gomb megnyomása után
lehet kiválasztani a szitálni kívánt szegmenseket, és a referencia előállításának
módszerét, majd az "Ellenőrzés" gombbal lehet megkezdeni a tényleges
folyamatot.

Az ellenőrzést parancssorból is lehet futtatni a check-segments scripttel.
A script első paraméterében a referencia módszerét várja,
ami lehet "sieve", vagy "test", a paraméterek maradéka az ellenőrizendő
szegmensek kezdőszáma kell legyen. Ha egy kezdet sincs megadva, akkor
a program az adatbázis könyvtárban található összes szegmensfájlt ellenőrzi.

\begin{lstlisting}[basicstyle=\tiny,language=bash]
scripts$ ./check-segments sieve
100.0%: A szegmensek helyesek.             

scripts$ ./check-segments sieve 0x1 0xc0000001
100.0%: A szegmensek helyesek.             

scripts$ ./check-segments test 0x1
100.0%: A szegmensek helyesek.             

\end{lstlisting}

Ha a kezdőszám nagyobb, mint $1$, a szitával ellenőrzéshez szükséges,
hogy az init program által előállított négy darab szegmensfájlt tartalmazza
az adatbáziskönyvtár, mert a szita kezdőszámra pozícionálásához a prímszámokat
innen olvassa fel a program.

{\color{red}screenshot}

\section{Sziták ellenőrzése}

Az sebességek összehasonlításához írt sziták eredményét is lehet ellenőrizni,
az összehasonlításhoz itt is a szegmensek ellenőrzésénél használt
egyszerű szegmentált szita a referencia.

A program grafikus felületén a "Sziták ellenőrzése" lehetőséget
választva ki kell választani az ellenőrizendő szitát, és az ellenőrizni
kívánt intervallum kezdő és végző számát.
A folyamat az "Ellenőrzés" gomb megnyomásával indítható.

Parancssorból is ellenőrizhetőek a sziták a "check-sieve" scripttel.
A script 3 paramétere a szita neve, és az intervallum kezdő-, és végszáma.
Az ellenőrizhető sziták nevei:

\begin{itemize}
\item atkin: Atkin szitája\cite{atkin}
\item cols: {\color{red}Cache optimized linear sieve}\cite{cols}
\item eratosthenes-segmented: Eratoszthenész szitájának szegmentált változata
\item bin-heap és bin-heap-inplace: Eratoszthenész szitája bináris kupaccal,
	az bin-heap-inplace a kupac javítását helyben végzi
\item buckets, buckets-n, buckets-simple: Eratoszthenész szitája, edénysorral

	a buckets-simple nem szegmentált, a buckets, és a buckets-n szegmentált.
	a buckets-n -ben az n helyére 1-től 8-ig a számrendszer bitjeit lehet megadni,
	pl. buckets-3 8as számrendszerben számol
\item trial-division: próbaosztás
\end{itemize}

A ''Sziták'' fejezetben található ezeknek a szitáknak a részletesebb leírása.

A sziták nevei listázhatóak a list-sieves scripttel, a describe-sieves script rövid leírást
is ad.

\begin{lstlisting}[basicstyle=\tiny,language=bash]
scripts$ ./check-sieve buckets-3 3000000000001 3010000000001
100.0%: A szita helyes.
\end{lstlisting}

Ha a kezdőszám nagyobb, mint egy, az ellenőrzéshez ilyenkor is szükséges,
hogy a négy darab kezdő szegmensfájlt tartalmazza az adatbáziskönyvtár.

{\color{red}screenshot}

\section{Minta megjelenítése}

A program a grafikus felületén képes mintákat ábrázolni, a mintákat függvényekkel
közelíteni, és ezeket a függvényeket is ábrázolni, valamint kiszámolja a közelítések
négyzetes hibáját a mintához képest.
A program egyváltozós, egyértékű mintákat kezel,
azok között is a természetes számokhoz valós számokat
rendelőket.
A minta akár külső forrásból is származhat.

A grafikonábrázoló részt a gui-graph scripttel lehet indítani,
vagy a gui scripttel, majd a "Grafikon" gomb megnyomásával.

Az ablak bal oldalán jelennek meg a betöltött minták és közelítő függvények
grafikonjai. Minta és függvény hozzáadása után a grafikon megjelenített részét
a program úgy választja meg, hogy minden minta összes pontja ebbe a nézetbe essen.
A nézet a grafikon feletti gombokkal, vagy egérrel mozgatható, nagyítható, vagy
kicsinyíthető.
Az ''Auto.nézet'' gombbal a nézet a minták teljes terjedelmére visszaállítható.

Az ablak jobb oldala a betöltött minták kezelésére szolgál.
A felső harmada az összes betöltött mintát mutatja.
Az ablak jobb oldalának alsó két harmadában az itt kiválasztott minta részletei
látszódnak.

\subsection{Minta hozzáadása} %%% EMIL: Ez itt "hozzáadása" nem inkább beolvasása... betöltése... hmm... nem tom.

A "Minta hozzáadásánál" három adatforrásból lehet választani.
A "Fájl betöltésével" CSV fájl olvasható be. A fájl formátuma megengedő,
az első oszlopot x, a második oszlopot y értékeknek próbálja értelmezni,
a fel nem ismert sorokat eldobja. Ha az első sor első oszlopa "BARS",
akkor vonaldiagram helyett a mintát oszlopdiagramként fogja ábrázolni.

A "Prímstatisztikák" a generator kimeneteléből összesített statisztikák,
amiket az adatbáziskönyvtárban keres.
A program a szegmensstatisztikák hiánytalan kezdőszeletét veszi csak figyelembe.
A statisztikáknak három csoportja van. A prímek száma, és néhány kiemelt alakú prím száma
a szegmensek végén. Ide tartozik ugyanezeken a helyeken a prímszámtétel
becslése, és a becslés abszolút és relatív hibája is.
A prímhézagok statisztikái a szegmensek teljes kezdőszeletére vonatkozik. Ezek
az előfordult hézagok gyakorisága, első előfordulása, jósága, és az legnagyobb
prímhézag adott számig.
Ezeken kívül a szegmensek szitálásának ideje is betölthető. Az összesített
idő a szegmensek végig az összes addigi szegmens összes ideje,
a szegmensenkénti a szegmensek végéhez az adott szegmens szitálásának idejét rendeli.

A minták harmadik forrása a programba épített sziták futási idejének mérése.
Ehhez meg kell adni a szitát, a szitált intervallum elejét és végét,
a szita belső szegmensméretét, a generálandó minták számát, és a mérések számát,
a mértéket, és hogy az eredményt összesítse-e.
A sziták listája ugyanaz, mint a sziták ellenőrzősénél.
A mintákat a program a szitált intervallumon egyenletesen osztja el a megadott méretű
szegmensek határainál. A teljes szitálást a megadott mérések számászor végzi el,
és az eredményt átlagolja.
Összesítést kiválasztva a minta értéke a szitált intervallum elejétől
az adott számig szitálás teljes ideje, különben az előző minta helyétől.
A mérték szabályozza, hogy a tényleges eltelt időt mérje a program nanoszekundumban,
vagy az elvégzett műveletek számát.

{\color{red}screenshot}

\subsection{Minta közelítése}

Az ablak jobb oldalának középső harmadában a kiválasztott minta részletei látszódnak.
Itt változtatható meg a minta ábrázolásához használt szín, távolítható el a minta,
vagy menthető CSV fájlba.

A táblázat a minta közelítéseit mutatja,
itt olvashatóak le a közelítés komponensfüggvényei, és a közelítés hibája.
A "Közelítés" gombbal lehet új közelítést hozzáadni az ábrázoláshoz.
A közelítéshez a lineáris legkisebb négyzetek módszerét használja a program,
ehhez a lineáris kombináció elemi függvényeit meg kell adni.
A függvények kiválaszthatóak az előre megadott listából,
vagy javascript nyelven is megadhatóak.
A közelítéshez csak olyan függvények használhatóak, amik a minta
minden pontjában értélmezve vannak.

Javascript függvényhez meg kell adni a függvény nevét és forráskódját.
A forráskódban a függvény argumentumára az $x$ változóval lehet hivatkozni,
és a script utolsó kifejezésének értéke lesz a függvény
értéke $x$-ben. Pl. az $x \mapsto \frac{\ln{x}}{x}$ hozzárendelés
forráskódja:

\begin{lstlisting}[basicstyle=\small, language=Java]
Math.log(x)/x
\end{lstlisting}

A scriptben használható változó, és a szokásos vezérlőutasítások.
Pl. az iterált logaritmus egy megadása:
\begin{lstlisting}[basicstyle=\small, language=Java,morekeywords=var]
var y=0;
while (1<x) {
  x=Math.log(x);
  ++y;
}
y
\end{lstlisting}

Az így megadott függvények visszatérési értéke mindig double kell legyen,
és a függvény azokban a pontokban értelmezett, ahol ez az érték véges.

Egy kiválasztott közelítés részletei az ablak jobb alsó sarkában látszódnak,
itt megváltoztatható a közelítéshez rendelt szín, és eltávolítható a közelítés.
A táblázat a közelítéshez kiválasztott függvények együtthatóit mutatja
a lineáris kombinációban.
%%% EMIL: Ezeket egy kicsit matekossan is leírhatod... megadod az f1 f2 függvényeket és a program megkeresi a lambda1 lambda2 skalárokat...

{\color{red}screenshot}

\section{Sziták mérése scriptekkel}

%%% EMLI: Ez nem inkonzisztens? Eddi úgy volt hogy egy szekcióban egy funkció (csoportot) írtál le, és ott volt a GUI és CLI végrehajtás is, nem így külön szekcióban, nem? (és hogy a francba mondják magyarul a "sectiont"?)
A sziták futási idejének mintáit parancssorból is elő lehet állítani
a measure-sieve scripttel, paraméterként meg kell adni ebben a sorrendben:

\begin{itemize}
\item a szita nevét, ezek ugyan azok lehetnek, mint a check-sieve scriptnél
\item a számot, ahol a szitálás kezdedődik, ez páratlan szám kell legyen
\item a szitálás végét, ez páratlan szám kell legyen
\item a szegmensek méretét
\item a mérések számát
\item a minták számát
\item hogy időt (nanosecs), vagy műveleteket (operations) mérjen
\item összesítse az időket ("sum"), vagy szegmensenként külön számolja ("segment")
\item a fájlt, ahova az eredményt mentse CSV-ben
\end{itemize}

A számokat meg lehet adni decimálisan, és hexadecimálisan is "0x" előtaggal.
Ha a kezdőszám nagyobb, mint 1, akkor az adatbáziskönyvtárnak tartalmaznia
kell az init program generálta első négy szegmenst.

Lehetőség van a mérték és az összesítés mind a négy kombinációját egy
méréssel előállítani, ehhez mind a négy kimeneti fájl meg kell adni külön.

\begin{lstlisting}[basicstyle=\tiny,language=bash]
scripts$ ./measure-sieve buckets-3 1 0x10000001 0x10000 3 1000 nanosecs sum out1.csv
100.0%
scripts$ ./measure-sieve buckets-3 1 0x10000001 0x10000 3 1000 operations segment out2.csv
100.0%
scripts$ ./measure-sieve buckets-3 1 0x10000001 0x10000 3 1000
seg-ns.csv seg-ops.csv sum-ns.csv sum-ops.csv
100.0%
\end{lstlisting}

A mérések megkönnyítéséhez a measure-sieves script az összes szitát megméri,
és az eredményt a samples könyvtárba menti.
A samples könyvtárban a mérési eredmények
4 külön könyvtárban szegmensenként/összesítve,
és idő/művelet szerinti bontásban vannak.
Ezekben a könyvtárakban 2 fajta mérés eredményei vannak.
Az atkin könyvtárban Atkin szitájának sebessége
van megmérve különböző szegmensméretek esetén.
A speed kezdetű könyvtárakban az összes szita
sebességének mérése található, $2^{20}$ szegmensmérettel.
A könyvtárak nevében a szám a szitálás kezdetét adja meg,
a speed$n$ könyvtárban a mérések $2^n+1$-től kezdődnek.
A lassabb szitákat csak kisebb nagyságrendekre
méri meg a script, ezek futási ideje hamar
túl naggyá válik.

A measure-generator script a generator program
sebességét méri meg, 3 változóban.
A szitálás kezdetének nagyságrendjén kívül
a szegmensméretet, és az edénysor számrendszerét
is variálja. Ennek a kimenete nem
használható a program mintamegjelenítésével,
mert az egy változós mintákkal dolgozik.
Ennek a mérésnek a célja az, hogy a generator program
paramétereit egy konkrét számítógéphez lehessen
igazítani.
A script 16db szegmensfájlt szitál,
a szitálás kezdetét $2^{33}$-től $2^{63}$-ig
változtatja, a kitevőt hármasával növelve,
a szegmensek méretét $2^{16}$-tól $2^{24}$-ig,
a kitevőt egyesével növelve,
és a számrendszert $2^1$-től $2^8$-ig,
szint a kitevőt egyesével növelve.

\chapter{Fejlesztői dokumentáció}

\section{A feladat leírása}

A program feladata, hogy lehetővé tegye prímsziták futási idejének összehasonlítását.
A prímsziták az egész számok egy intervallumán
minden számról eldönti, hogy a szám prím, vagy összetett.
A program keretet ad, hogy azonos paraméterekkel lehessen a sziták futási idejét mérni,
és egyszerű, egymáshoz hasonlóan optimalizált szitákat implementál,
hogy a futási időket a fő algoritmusok határozzák meg, mivel a szitálást felgyorsító
egyes ötletek nem minden szitán alkalmazhatóak.
A futási időt eltelt időben, és összeszámolt műveletekben méri.
%%% EMIL: Itt is érvényes, hogy csomó dolog, mint pl a szita fogalma nincs definiálva.  Akármennyire is trivi. Prímeket keresünk (a prímeket pl nem feltétlenül kell már definiálni), de akár az egyszerű SOE-t is érdemes leírni.

A szitákat szegmentáltan valósítja meg,
a szegmensek mérete, és a szitálandó intervallum
kezdete és vége szabályozható. A megvalósított sziták:
\begin{itemize}
\item Atkin szitája
\item Eratoszthenész szitája
\begin{itemize}
\item egyszerű tömbbel
\item bináris kupaccal
\item edényekkel
\item monoton edénysorral
\end{itemize}
\end{itemize}

A programnak grafikusan ábrázolja a futási időket, és lehetőséget ad
ezek közelítésére függvényekkel. A közelítéshez a legkisebb négyzetek módszerét használja,
és a közelítés elemi függvényei megválaszthatóak.
A program megjeleníti a közelítések négyzetes eltérését is a mintához képest.
Elemi függvény meg lehet adni JavaScript nyelven is.

A grafikus ábrázolás képes külső forrásokból származó minták megjelenítésére és közelítésére is.

A minták és függvények ábrázolása interaktív, az éppen megjelenített
intervallum elhelyezkedése és mérete megválasztható.
Egyszerre több mintha is megjeleníthető,
és minden mintához egyszerre több közelítő függvény is tartozhat.

A prímszámok statisztikáinak megjelenítéséhez
elő tudja állítani ezeket a statisztikákat nagyobb intervallumokon is.
Ehhez ad egy szitát, ami hatékonyan képes $2^{64}$-ig szitálni,
és ennek az eredményét összesíteni. Az előállítható statisztikák
adott $n$-ig szitálva:
\begin{itemize}
\item a prímek száma
\item a $4\mathbb{Z}+1, 4\mathbb{Z}+3, 6\mathbb{Z}+1, 12\mathbb{Z}+11$
	alakú prímek száma
\item ikerprímek számát
\item az előforduló prímhézagok első előfordulásának helye
\item a prímhézagok előfordulásának száma
\item a szitálásra fordított idő
\end{itemize}

A prímek számát, és a szitálás idejét az intervallum belsejében is több ponton elkészíti.

A sziták sebességének mérését, és a statisztikák előállítását
parancssorból is el tudja végezni, hogy szkriptekkel ez automatizálható legyen.
A statisztikák előállításának folyamata
bármikor adatvesztés leállítható, és később folytatható.

%%% EMLI: kb eddig olvastam, a többin csak átfutott a szemem... majd mindjárt írok levelet.
\section{A program komponensei}

{\color{red}Ábra.

init -> db -> generátor -> db -> összesítő -> db -> minta megjelenítés -> minta közelítés -> közelítés megjelenítés

db -> info

db -> sziták -> futási idő minta -> minta megjelenítés -> minta közelítés -> közelítés megjelenítés

db -> ellenőrzés

db -> sziták -> ellenőrzés
}

A program az adatbáziskönyvtárban tárolja az átszitált szegmensek tábláit,
és az ezekből készült statisztikákat. A szegmensfájlokban egy $2^{30}$ hosszú
intervallum minden páratlan számához hozzá van rendelve, hogy az az szám
összetett vagy prím, és minden szegmens kezdő száma kongruens $1 (mod\ 2^{30})$.

Az első négy szegmenst az init program készíti el, így ezek $2^{32}$-ig tartalmazzák
a prímszámokat. A program többi szitája ezek alapján inicializálja magát,
ha $3$-nál nagyobb számtól kell a szitálást elkezdeni.
Ez a négy fájl bármikor újragenerálható, de ezeket érdemes a futások között megtartani.

A generátor egy optimalizált szita, $2^{32}$-től $2^{64}-2^{34}$-ig képes szitálni,
mindig egész szegmenseket, és az eredményt az adatbáziskönyvtárba menti.
Ezekre a szegmensfájlokra összesítés és ellenőrzés után többet nincs már szükség.
A szitálást tetszőleges szegmenstől lehet kezdeni a megengedett tartományon belül,
nem szükséges sorban végigmenni a számokon.
Az utolsó $2^{34}$ szám kihagyása egyszerű
optimalizáció, így a programban az éppen
szitált szám változója sosem csordul túl.

Az init és a generator csak konzol módban futtaható.
A program többi része a gui nevű Java program része,
de az automatizáláshoz az adatbázissal kapcsolatos műveletei
parancssorból is elérhetőek, ezek az adatbázis információ lekérése,
az új szegmensfájlok ellenőrzése, és összesítése, és az összesítőfájlök összefésülése.
Az időigényessége miatt a futási idő összehasonlításához implementált
sziták ellenőrzése is futtatható grafikus felületen, és parancssorból is.

Az adatbázis információ kilistázza a szegmensfájlok számát,
az összesített szegmensfájlok számát, ezen szegmensek intervallumának kezdetét
és végét, a még nem összesített szegmensfájlok számát.
Ezek alapján eldönthető, szitálást vagy az összesítést
hogyan kell folytatni, hogy a teljes $2^{64}$-ig intervallum statisztikái elkészüljenek.

A szegmensfájlok ellenőrizhetőek, ehhez egy, a generator-tól különböző
eratosthenészi szita, vagy az erős pszeudo-prímteszt előállítja
a szegmens ellenőrzött részét, és a program a kettőt összehasonlítja.
A szita lényegesen lassabb, mint a generator, és a pszeudo-prímteszt
időigénye miatt intervallumok szitálásra nem alkalmas,
a szegmensfájlok ellenőrzése alapvetően a generator helyességének
tesztelésére való, minden összesített szegmens ellenőrzése megtöbbszörözné
a szükséges időt.

Az összesítő az adatbáziskönyvtárban található szegmensfájlok statisztikáit készíti el,
és ezeket a szegmensstatisztikákat szintén az adatbázisban tárolja.
A szegmensstatisztikák alapján a végső statisztikákat közvetlenül
a megjelenítés előtt készíti el az összesítő.
Az összesítéshez sem szükséges, hogy a szegmensek sorban kerüljenek összesítésre,
így akár több gépen párhuzamosan is lehetne szitálni, összesíteni,
majd az eredményt összefésülni.

A program része több, különböző algoritmusú prímszita.
Ezeknek az eredménye ellenőrizhető a szegmensfájlok ellenőrzéséhez
használt szitával, szintén a sziták helyességének teszteléséhez.
A feladat része, hogy ezeknek a szitáknak a futási idejét össze lehessen hasonlítani,
ezért mindegyik szita néhány jól meghatárzotott ötlet egyszerű megvalósítása
optimalizálások nélkül.
Mindegyik szita szegmentált, a szitálást fix hosszúságú intervallumokon végzi,
bármelyik szegmenstől képes kezdeni a szitálást, és egy szegmens szitálása után
további előkészület nélkül képes szitálni a következő szegmenst,
így egyetlen menetben akár több szegmenshez tartozó futási idő is megmérhető,
nem szükséges minden mintavételi pontig a teljes szitálást elvégezni.

A minták közelítése alapfüggvények lineáris kombinációjával történik,
a legkisebb négyzetek módszerét használva.

A program a mintákat és közelítő függvényeket Descartes-féle koordinátarendszerben
jeleníti meg, ehhez a mintákat és a függvényket mintavételezi az x tengely
kiválasztott szakaszának pixelenkénti felosztása szerint.

\section{A forráskód}

A megoldás 3 programból áll, az init és a generator C nyelven készült el,
az összes többi részfeladat a gui nevű Java nyelven írt programban lett megoldva.

\subsection{Init és generator}

Az init és a generator forráskódja a tarball generator
könyvtárában van. A két program egymáshoz nagyon hasonló
feladatot lát el, hasonló megoldásokkal.
Mindkettő $2^{30}$ hosszú intervallumokat szitál,
és az eredményt szegmensfájlokba írja.
Ehhez mindkettő Eratoszthenés szitáját használja.
Mindkét program ezt az egyetlen feladatot oldja meg,
és scriptekkel automatizált, kötegelt futásra van tervezve.

\subsubsection{Közös rész}

A két program közös kódja a common.h fájl.
Ez a fájl tartalmazza a konstansokat,
és az eljárásokat, amik megkönnyítik
a POSIX hívások használatát.
A legtöbb ilyen könnyítés a hibák kezelésének
elfedése, ami a kötegelt futtatáshoz illeszkedően
a hiba kijelzése utáni azonnali programleállás.
Az I/O műveleteket könnyítik meg a readFully/writeFully
eljárások.

A sziták belső, kis szegmensmérete a
SEGMENT\_SMALL\_SIZE\_BITS\_LOG2 konstanssal
szabályozható, és a measure-generator script
kimenete alapján egy adott géphez igazítható.

Ez a közös header fájl határozza meg a szegmensfájlok
formátumát, a readSegment/writeSegment eljárásokkal.
A fájl neve a "primes." előtaggal kell kezdődjön,
és a pontosan 16 hexadecimális számjegy kell kövesse,
a szegmens által leírt első szám.
A fájl egyszerű bináris fájl, kis endian sorrendben.
A tartalma:
\begin{itemize}
\item a szegmens elejével kezdve $2^{29}$ egymást követő
	páratlan szám bittérképe.
	
	Ez $2^{26}$ byte, kis endian sorrendben minden bit
	egy szám összetettségét írja le. Ha a bit $1$,
	akkor a szám összetett, ha $0$, akkor a szám prím.
	Ha $s$ a szegmens intervallumának kezdete, akkor
	az $0.$ bájt $0.$ bitje $s$-t írja le,
	a $0.$ bájt $1.$ bitje $s+2$-t,
	a $k.$ bájt $l.$ bitje $s+16k+2l$-t.
	
\item a szegmens kezdete, 8 bájt
\item a szegmens szitálására való felkészülés ideje,
	8 bájt, nanoszekundumokban
\item a szegmens szitálásának ideje, 8 bájt, nanoszekundumokban
\end{itemize}

A writeSegment meghatározza a szegmensfájlok írásának
menetét is. A bármikori leállíthatósághoz a szegmensfájl
kiírása először egy ideiglenes fájlba történik,
és ha ez hiba nélkül megtörtént, akkor
a az ideglenes fájlt átnevezi a megfelelő névre.
Mivel az ideiglenes fájl ugyanabba a könyvtárba kerül,
mint ahova a szegmensfájl is, így feltételezhető,
hogy helyi meghajtón az átnevezés már atomi művelet.

Ez az eljárás az átnevezés előtt nem győződik
meg arról, hogy az ideiglenes fájl minden része
kiíródott a háttértárra, így ez csak a program
leállíthatóságát garantálja,
a számítógép váratlan leállása esetén érdemes
azokat a szegmensfájlokat letörölni, amikről
feltételezhető, hogy nem volt ideje a számítógépnek
minden részét kiírnia a tényleges tárolóra.

\subsubsection{Init}

Az init program előállítja az első 4 szegmens fájlát,
azaz $2^{32}$-ig az összes prímet megkeresi.
Ezzel a többi részprogram már a $2^{32} - 2^{64}$
tartomány tetszőleges részén tud szitálni,
anélkül, hogy a szitált szegmenseket a szitálás
végén végig kéne nézze új prímekért.

A szita egy egyszerű szegmentált eratoszthenészi szita.
A $2^{30}$ hosszú szegmenseket több kisebb, egyenlő
szegmensre osztja, és ezeket a kis szegmenseket
egymás után szitálja a prímek listáján végigmenve.

A prímek mellett a következő szitálás
helyét is eltárolja, így nem kell minden szegmens
szitálásának elején minden prímhez osztással
meghatározni, hogy melyik a legkisebb szám
a szegmensben, amit az oszt.

Így egy kis szegmensben egy prímre
a következő algoritmus fut le.
Ez az algoritmus visszatérő minta a szegmentált szitákban.

\begin{algorithmic}[1]
\State p: \text{a prím}
\State q: \text{a következő szám, amit p oszt}
\State e: \text{a szegmens vége}
\While{q < e}
	\State \Call{Megjelöl}{q}
	\State q = q + 2p
\EndWhile
\end{algorithmic}

A prímek listáját elég $2^{16}$-ig előállítai,
ezt a program próbaosztással végzi el.

\subsubsection{Generator}

A generator fő részei hasonlóak az init-hez.
Indulása után felolvassa az összes prímet
az első 4 szegmensfájlból, és mindegyik
prímhez meghatározza, hogy melyik a legkisebb
szám, amit oszt, és legalább akkora, mint legelső
szitálandó szegmens kezdete.
A prímek, és a hozzájuk tartozó következő szitálandó
pozíciót tároló adatstruktúra szitálás közben
nem érzékeny azokra az elemekre, amik az éppen szitált szegmensnél
nagyobb helyeken szitálnak, így a generator
az összes prímet eltárolja $2^{32}$-ig, nem csak
a szitálandó tartomány végének négyzetgyökéig,
és a prímek első többszörösét is a prím
négyzetétől szitálja.

A prímek listájának inicializálása után
a nagy szegmenseket az inithez hasonlóan kisebbekre osztja,
és ezeket sorban szitálja a prímek listája alapján.

A prímek listája a generatorban több külön
adatszerkezet összessége. A prímeket a szita
inicilizálásánál 3 részre osztja a nagyságuk szerint.
A $64$-nél kisebb prímeket $64$-bit széles bitmintákban
tárolja, és ezekkel a mintákkal $64$-bitesével szitálja
végig a kisszegmenseket a bitenkénti vagy művelettel.
A 3 és a 11, valamint az 5 és a 7 szorzata kisebb, mint 64,
ezeket a párokat egyetlen $64$ bites mintába fejti ki,
ezeknek a mintáknak a periódisa 33, és 35.
A többi prím mintájának periódusa a legnagyobb olyan szám,
ami 64-nél kisebb, és a prím osztja.

A prímek, amik $64$-nél nagyobbak, de a
kis szegmensek hosszánál kisebbek, azaz minden kis szegmensben
szitálnak, az init-hez hasonlóan egy egyszerű tömbbe
kerülnek, és ugyanúgy szitál ezekkel a program, mint
az init-ben.

A kis szegmensek hosszánál nagyobb prímek
egy kis szegmensben legfeljebb egyszer szitálnak,
és van olyan szegmens, ahol egyszer sem.
A generator ezeket a prímeket egy prioritásos
sorban tárolja, amiben az elemek sorrendjét
a következő szegmens száma határozza meg,
amiben az a prím szitálni fog, a szegmensen
belüli sorrendet a sor nem veszi figyelembe.
Ezeknél a nagy prímeknél nem csak a páros
többszörösöket ugorja át a szita, hanem
a 3-mal és 5-tel osztható többszörösöket is
kihagyja. {\color{red}mi a kerék magyarul?}

Az edénysor algoritmusának részletes leírására egy későbbi fejezetben kerül sor.
Az ott leírt távolság függvényt implementálja a bucketIndex függvény
a forráskódban. A számrendszert a BUCKET\_BITS konstans szabályozza.
A sorhoz tartozó edények listája a buckets tömb, ennek minden eleme
egy láncolt lista, ahol a listaelemek fix méretű edények.

A program futása alatt a sor elemeinek száma nem változik,
de az elemek az edények között mozognak. A sor legkisebb elemeinek,
azaz az aktuális szegmensben szitáló prímek megkereséséhez
a lista egyik edényének minden elemét
megvizsgálja, ha egy elem az aktuális
szegmensben nem szitál, akkor az elemet a sorba visszahelyezi,
a távolság függvény szerint már közelebbi edénybe, ha pedig
az elem szitál az aktuális szegmensben, akkor elvégzi a szitálást,
és az elemet visszateszi a sorba, azon pozíció szerint, ahol a
prím legközelebb szitálni fog.

A 2, 3, és 5 többszöröseinek hatékony kihagyásához
a prioritásos sor elemeiben a pozíció mellett el van tárolva,
hogy az a pozíció melyik modulo 30 maradékosztály eleme.
A nyolc szóbajöhető lehetőség közül a PrimePosition.prime mező
felső 3 bitje választ. Ezt a 3 bit információt biztonsággal
lehet itt tárolni, a 64 bit széles változóból a feladat jellege
miatt mindig csak az alsó 32 tartalmaz értékes számjegyet.
A 2-3-5 kerék alapú gyorsítás csak a prioritásos sorban
tárolt nagy prímekre van alkalmazva.

\subsection{Gui}

\subsubsection{gui.util}

\subsubsection{gui.io}

\subsubsection{gui.sieve}

\subsubsection{gui.math}

\subsubsection{gui.ui}

\subsubsection{Grafikus felület}

\section{Adatszerkezetek}

\section{Numerikus algoritmusok}

Egyenletrendszerek. Összeadás.
Körül kéne írni, hogy igazán tudjuk, hogy hipotézisvizsgálatra nem vállalkozunk.
A grafikonrajzolónak sokkal okosabbnak kéne lennie, hogy gyorsan változó függvényeket
helyesen jelenítsen meg, reménytelenül okosnak.

\section{Sziták}

Eratosztenész szitája, szegmentáltan is. COLS. Prioritásos sorral. Atkin szitája.

Szegmentált szita inicializálása.

Trial division. Pszeudoprím teszt.

Feltételek. Elméleti sebesség.

\section{Prioritásos sorok}

\begin{algorithmic}[1]
\State $q \gets$ \Call{Új-sor}{}
\For{$i\gets 2, n$}
	\While{$\exists (p, k) \in q: k \le i$}
		\State $(p, k) \gets $ \Call{Sor-Eltávolít-Min}{q}
		\State \Call{Megjelöl}{i}
		\State \Call{Sor-Beszúr}{q, (p, k+p)}
	\EndWhile
	\If{$\neg$ \Call{Megjelölt?}{i}}
		\State \Call{Sor-Beszúr}{q, (i, 2i)}
	\EndIf
\EndFor
\end{algorithmic}

\subsection{Bináris kupac}

A mérések grafikonják pixelei alapján lassú. A beszúrásonkénti elméleti
$\mathcal{O}(log_{}{|q|})$ ideje se biztató.

\subsection{Bigyó} %%% EMIL: Ettől SOKKAL jobb nevet kell találni neki!!!!

A bigyó egy monoton prioritásos sor.
A sor monoton, minden állapotához tartozik egy érték, a sor aktuális pozíciója,
aminél kisebb vagy egyenlő pozíciójú értéket a sor nem tartalmazhat.
A bigyó edények egy végtelen sorozatát is tárolja, a sor elemei ezekbe az edényekbe kerülnek.
Egy eltárolt elem helyét a sorozatban az elem pozíciójának
és a sor aktuális pozíciójának távolsága határozza meg.

A távolságfüggvény legyen

\begin{align*}
d(x, y) := \lfloor log_{2}{}(x \oplus y) \rfloor & & (x, y \in \mathbb{N}, y > x \ge 0)
\end{align*}

ahol $\oplus$ a bitenkénti XOR.

$d(x, y)$ a legnagyobb bit-index, ahol $x$ és $y$ eltér.

Ha $q$ egy bigyó, legyen $q.a$ $q$ aktuális pozíciója, és $q.e[i]$ $q$ $i$. edénye. AZ edények, és a számpárok struktúrája...

Egy q bigyó invariánsa
\begin{align*}
\forall (p, k) \in q &: &\\ 
	& q.a < k\\
	& \forall i \in \mathbb{N}_{0}: (p, k) \in q.e[i] \iff i=d(q.a, k) \\
\forall (p, k) \not\in q &: \forall i \in \mathbb{N}_{0}: (p, k) \not\in q.e[i]
\end{align*}

Új, üres sor létrehozása tetszőleges kezdőpozíciótól, és meglévő sorba elem beszúrása...

A sor elemeinek feldolgozása $i$-ig
\begin{algorithmic}[1]
\While{$q.a < i$}
	\State $j \gets d(q.a, q.a + 1)$
	\State $q.a \gets q.a + 1$
	\ForAll{$(p, k) \in q.e[j]$}
		\State \Call{Edény-Kivesz}{$q.e[j], (p, k)$}
		\If{$k = i$}
			\State \Call{Visszaad}{$(p, k)$}
		\Else
			\State \Call{Edény-Beszúr}{$d(q.a, k), (p, k)$}
		\EndIf
	\EndFor
\EndWhile
\end{algorithmic}

\subsubsection{Helyesség}

\subsubsection{Idő}

\subsubsection{Hely}

\subsubsection{Számrendszer}

És számrendszer vs. tisztán funkcionálisban nincs bármekkora tömb, csak valami fával közelítve.

Amúgy sincs bármekkora tömb...

És exponenciálisan kell növelni...

\subsubsection{Cache}

És exponenciálisan kell növelni...

\section{Memória}

Összes prím, és pozíciója $2^32$-ig. Primitív típusok és boxing. Garbage collector.

\section{Teszt}

\subsection{Adatszerkezetek}

\subsection{Numerikus pontosság és sebesség}

\subsection{Sziták}

\subsection{Elmélet vs. mért}

\begin{thebibliography}{9}

\bibitem{atkin} 
A. O. L. Atkin, D. J. Bernstein: Prime sieves using binary quadratic forms, Mathematics of Computation, Volume 73 (2004) 1023–1030

\bibitem{cols} 
A. Járai, E. Vatai: Cache optimized linear sieve, Acta Univ. Sapientiae, Inform. 3,2 (2011) 205-223

\end{thebibliography}



\end{document}

\documentclass[12pt]{report}
\usepackage[a4paper,
			inner = 35mm,
			outer = 25mm,
			top = 25mm,
			bottom = 25mm]{geometry}
\usepackage{lmodern}
\usepackage[magyar]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[unicode]{hyperref}
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{epstopdf}
\usepackage{setspace}
\usepackage[nottoc,numbib]{tocbibind}
\usepackage{color}
\setcounter{secnumdepth}{3}
\usepackage{algpseudocode}
\usepackage{listings}
\usepackage{titlesec}
\onehalfspacing
\lstset{literate=
  {á}{{\'a}}1 {é}{{\'e}}1 {í}{{\'i}}1 {ó}{{\'o}}1 {ú}{{\'u}}1
  {Á}{{\'A}}1 {É}{{\'E}}1 {Í}{{\'I}}1 {Ó}{{\'O}}1 {Ú}{{\'U}}1
  {à}{{\`a}}1 {è}{{\`e}}1 {ì}{{\`i}}1 {ò}{{\`o}}1 {ù}{{\`u}}1
  {À}{{\`A}}1 {È}{{\'E}}1 {Ì}{{\`I}}1 {Ò}{{\`O}}1 {Ù}{{\`U}}1
  {ä}{{\"a}}1 {ë}{{\"e}}1 {ï}{{\"i}}1 {ö}{{\"o}}1 {ü}{{\"u}}1
  {Ä}{{\"A}}1 {Ë}{{\"E}}1 {Ï}{{\"I}}1 {Ö}{{\"O}}1 {Ü}{{\"U}}1
  {â}{{\^a}}1 {ê}{{\^e}}1 {î}{{\^i}}1 {ô}{{\^o}}1 {û}{{\^u}}1
  {Â}{{\^A}}1 {Ê}{{\^E}}1 {Î}{{\^I}}1 {Ô}{{\^O}}1 {Û}{{\^U}}1
  {œ}{{\oe}}1 {Œ}{{\OE}}1 {æ}{{\ae}}1 {Æ}{{\AE}}1 {ß}{{\ss}}1
  {ű}{{\H{u}}}1 {Ű}{{\H{U}}}1 {ő}{{\H{o}}}1 {Ő}{{\H{O}}}1
  {ç}{{\c c}}1 {Ç}{{\c C}}1 {ø}{{\o}}1 {å}{{\r a}}1 {Å}{{\r A}}1
  {€}{{\euro}}1 {£}{{\pounds}}1 {«}{{\guillemotleft}}1
  {»}{{\guillemotright}}1 {ñ}{{\~n}}1 {Ñ}{{\~N}}1 {¿}{{?`}}1
}
\begin{document}
\begin{titlepage}
\vspace*{0cm}
\centering
\begin{tabular}{cp{2cm}c}
\begin{minipage}{4cm}
\vspace{0pt}
\includegraphics[width=1\textwidth]{eltecimerszines}
\end{minipage} & &
\begin{minipage}{7cm}
\vspace{0pt}Eötvös Loránd Tudományegyetem \vspace{10pt} \newline
Informatikai Kar \vspace{10pt} \newline
Komputeralgebra Tanszék
\end{minipage}
\end{tabular}

\vspace*{0.2cm}
\rule{\textwidth}{1pt}

\vspace*{6cm}
{\Huge Prímszita algoritmusok összehasonlítása}

\vspace*{5cm}
\begin{tabular}{lp{3cm}l}
Vatai Emil & & Nagy Péter\\
Adjunktus & & Programtervező Informatikus BSc
\end{tabular}

\vfill

\vspace*{1cm}
Budapest, 2018
\end{titlepage}

\tableofcontents

\chapter{Bevezetés}

%%% EMIL: Ezeket a mondatokat feltételezem majd kifejted rendesen.
Sziták összehasonlítása azonos környezetben.
Hatékonyság összehasonlítása az elmélet szerint várható értékekkel.
Ellenőrzésként a prímek néhány statisztikájának összevetése az elméleti értékekkel,
és az ismert eredményekkel.
Hatékonyság és implementálhatóság.

%%% EMIL: Ötlet/javaslat: szétszedni kisebb fájlokba a dolgot include-okkal.
\chapter{Felhasználói dokumentáció}

\section{A megoldott feladat}

A program lehetővé teszi különböző sziták futási idejének ábrázolását grafikonon,
és összevetését elméleti becsült értékekkel.
A programmal egyéb forrásból származó minták megjelenítése is lehetséges.

%%% EMIL: Helyesírás ellenőrzős van az editorodban? Ha nincs akkor legyen! Ha emacs akkor könnyen tudok segíteni ebben a kérdésben. (ld hiányzó 'l' betű).
A prímszámok statisztikáinak előállításához a programhoz tartozik egy optimalizált
szita-implementáció, amivel $2^{64}$-ig lehet szitálni, és az eredményt rögzíteni.
Az elmentett eredményeket a program egy külön része összesíti néhány alapstatisztikára.  %%% EMIL: "...összesíti alapstatisztikára..." ezzel a kifejezéssel nem tudom találkoztam-e... nyelvi kérdés, és világos mit jelent, lehet hogy az én hiányosságom... nem tudom így használják-e.

%%% EMIL: Ezt lehet érdemes összevonni az előző bekezdéssel, ott is emlegetsz implementációkat.
Különböző szita-algoritmusok futási idejének összehasonlításához a program tartalmazza
Atkin szitájának egy implementációját, és Eratosztenész szitájának néhány variációját.

\section{Felhasznált módszerek}

A program két fő részből áll.
%%% EMIL: Ide egy \subsection{Első rész/Első program}???
A prímszámok generátora C-99 nyelven készült el.  %%% EMIL: A '-99' fontos? Simán C nem elég? Esetleg: "C nyelve (C-99 szabvány)..."? (a másik rész az Java... úgy hogy...)
A program csak parancssorból futtatható, és a sztenderd könvytári függvényekből
is csak néhányat használ a memóriájában előállítótt eredmények fájlba írásához.
A C nyelv választását a hatékony végrehajtás és memórafelhasználás, és
a hordozhatóság indokolja, a generátor elkülönítését az automatizálhatóság indokolja.

A prímgenerátor Eratosztenész szitájának szegmentált változata,
a szitatábla egy $2^{30}$ hosszú darabját szitálja ki minden iterációban.
A generátor önmaga is két részből áll.
Egy egyszerűbb implementáció a prímek listáját állítja elő $2^{32}$-ig.

A gyorsabb, de összetettebb szita $2^{32}$-től $2^{64}-2^{34}$-ig szitál,
és a futásához szükséges a prímek listája $2^{32}$-ig.
A szitatáblát a memóriában a gyorsítótár hatékonyabb a kihasználásához kisebb
résszegemensekre osztja,
és a prímeket a nagyságuk és a következő szitálási pozíciójuk szerint csoportosítja.
Továbbá nagyobb prímeknek csak harminccal relatív prím többszöröseit veszi figyelembe.

A program többi része a Java környezethez készült, a képzésben betöltött szerepe és
a hordozhatósága miatt.  %%% EMIL: Ez a mondat mintha kicsit túl lenne rizsázva.
A minták és függvények ábrázolásához használt Swing grafikus könyvtár
a Java környezet része, egyszerű, hordozható, támogatja az élsimítást,
és a sebessége elfogadható a feladatra.
A Java sztenderd konténerosztájai habár kényelmesen használhatóak, és változatosak,
de sebesség és memóriakihasználtsági problémák miatt több helyen is alacsonyabb szintű
megoldást kellett választani.  %%% EMIL: Most kezdek azon morfondírozni hogy itt sokat írsz a fejlesztői döntésekről és keveset a program felhasználásáról. Ezt majd érdemes lesz figyelembe venni.
%%% EMIL: Itt ha gondolod inkább ilyen Gauss és hasonló prímek eloszlására vonatkozó rizsát lehet írni és valahogy összekötni azzal hogy mit old meg a program (ahelyett hogy leírod hogy HOGYAN oldja meg ezeket)

A program a mintákat alapfüggvények lineáris kombinációjával képes közelíteni,
a legkisebb négyzetek módszerével. A minták elemeinek nagy száma, és a mintaértékek
nagy terjedelme miatt szükséges volt a numerikus algoritmusok nagyobb pontosságú
implementációja, ami a számítási idő növekedésével jár.

A program hosszabb távon egyedül a prímek szegmensenkénti statisztikáit tárolja,
amit csak sorban dolgoz fel, és a statisztikák összmérete sem indokolna
egy egyszerű bináris fájlnál bonyolultabb megoldást. Az adatvesztés elkerüléséhez
elég a statiszikafájl csere alapú felülírása.

A Java program tartalmaz több prímszita implementációt is, ezeknek az algoritmikus
bonyolultsága különböző, de az összehasonlíthatósághoz a közös részek közös
implementációt kaptak, és az eltérő részek hasonló szinten optimalizáltak.
A sziták helyességének ellenőrzéséhez a sziták eredménye egymással összehasonlítható.
A programhoz elkészült Atkin szitája, és Eratoszthenész szitájának több variációja:
az algoritmus legegyszerűbb implementációja a teljes szitatáblán jelöli meg
a prímek többszöröseit, a többi a táblát rövidebb szegmensekre osztja fel,
és ezeket sorban szitálja. A szegmentálás szükségessé teszi, hogy eldöntsük,
hogy mely szegmensben mely prímek szitálnak. A legegyszerűbb megvalósítás
minden szegmensben minden prímmel megpróbál szitálni, a próbaosztáshoz hasonlóan.
Ennél hatékonyabb a két elsőbbségi sorral megvalósított szita, és a harmadik,
edényekbe csoportosító megoldás.

A sziták között kapott helyet a próbaosztás, és az erős pszeudo-prím teszt is,
de ezek a lassúságuk miatt csak igen rövid tartományok ellenőrzésére alkalmasak.

%%% EMIL: Ez nem teljesen világos, szóval van egy nagy és gyors szita C-ben és több kisebb és lassabb szita plusz egy megjelenítő a Java programban. Ez nagyon alacsony prioritású megjegyzés, azaz szinte csak kérdés. Jó gondolom hogy talán "szebb" lenne ha a szitálást egyik program csinálná, a megjelenítést meg a másik - vagy valamit nem veszek figyelembe?

\section{A program telepítése és futtatása}

A program futtatásához Windows vagy Linux operációs rendszer szükséges,
legalább 4GB szabad memóriával.
A Java program futtatásához JRE8 szükséges, a fordításához JDK8.
A C program fordításához C99 szabványú fordítóprogram kell.  %%% EMIL: Konzisztensen C-99 vagy C99-et használj (vagy sima C-t)
A program fejlesztése és tesztelése OpenJDK8-cal és GCC 7.3-mal történt
Linux operációs rendszeren.

%%% EMIL: A "tarball"-t tökéletesen tudom micsoda, nem tom hogy mennyire "magyar" kifejezés és gondold meg hogy akarod-e használni a dolgozatban (nekem tetszik, én támogatom használatát).  És azt is lehet érdemes oda írni hogy milyen/melyik tarball-ról beszélünk, "Programot tartalmazó tarball", "CDn mellékleten található tarball" "Githubról letölthető tarball".
%%% EMIL: A másik dolog amit támogatok hogy beírod a github repo url-jét is.
A tarball a Java programot lefordítva is tartalmazza,
kicsomagolás után azonnal futtatható.
A C programot a generator könyvtárban található Makefile segítségével lehet lefordítani:
{\tiny
\begin{lstlisting}[language=bash]
generator$ make clean build
\end{lstlisting}
}

%%% EMIL: Ez a szöveg is a \tiny{..}ban van, és furcsák a sortávolságok.  A listings bash beállításait érdemes piszkálni, hogy automatikusan azt csinálja amit szeretnél. https://tex.stackexchange.com/questions/180222/how-to-change-font-size-for-specific-lstlisting

A Java program a NetBeans 8-as verziójával készült,
parancssorból a project ant fájlának segítségével lehet
újrafordítani:
{\tiny
\begin{lstlisting}[language=bash]
gui$ ant clean jar
\end{lstlisting}
}

A program futtatásához több előkészített script is rendelkezésre áll,
ezeket mind a scripts könyvtárból lehet indítani.
Az előző két fordítást egyben is el lehet végezni a recompile scripttel:
{\tiny
\begin{lstlisting}[language=bash]
scripts$ ./recompile
\end{lstlisting}
}

\section{Prímek keresése}

%%% EMIL: Az 'init' a 'generátor' és hasonló programokat érdemes lett volna a legelején definiálni (ott ahol írod hogy két részből áll a dolog stb).
A prímek keresését két program végzi, az init program
$2^{32}$-ig keresi meg és tárolja el a prímeket,
a generator $2^{32}$-től $2^{64}-2^{43}$-ig.
Az init készítette szitattáblák a generator futásához szükségesek.

Mindkét program a számokat $2^{30}$ hosszú táblánkként szitálja,
minden tábla első száma $2^{30}k+1$ alakú. A szitatáblákat a programok a
fájlrendszerben bittérképként tárolják, egy tábla kb. $64$Mb.  %%% EMIL: Nem inkább bitvektór?

Az első négymilliárd szám szitálása a következő képpen indítható el:

{\tiny
\begin{lstlisting}[language=bash]
generator$ ./init.bin ../db
szegmens 0 - kezdet             1 - felkészülés 159 906 063 ns - szitálás 1 122 878 403 ns
szegmens 1 - kezdet 1 073 741 825 - felkészülés   2 353 698 ns - szitálás 1 171 101 336 ns
szegmens 2 - kezdet 2 147 483 649 - felkészülés   2 344 515 ns - szitálás 1 188 330 478 ns
szegmens 3 - kezdet 3 221 225 473 - felkészülés   2 391 660 ns - szitálás 1 199 900 603 ns
\end{lstlisting}
}

Ennek eredmény 4 bittérképfájl, amit a db mappába ment.  %%% EMIL: Az előző üres sort kitörölném, mert ez a mondat az előző bekezdéshez tartozik.

A generator programot több féle képpen is lehet indítani.
Mindegyik esetben két paramétert kell megadni az indításhoz,
a számot, ahol szitálást kezdje, és a szegmensek számát, amit
ebben a futásban végig kell szitálni.
A kezdő számot meg lehet adni decimálisan is, vagy hexadecimálisan is,
"0x" prefixszel. A szegmensek számát is kétféle képpen lehet szabályozni.
Az egyik lehetőség fix számú szegmens megadása, decimálisan.
A másik mód a háttértáron fenntartandó szabad hely átadása, decimálisan,
vagy "0x" prefixszel hexadecimálisan.  %%% EMIL: Ezt nem árt részletezni, hogy a 'segments' (ami 'numsegments' is lehetne) és a 'reserve-space' paraméterrel lehet megadni.  Ezek viselkedését lehet nem árt pontosabban megadni.

{\tiny
\begin{lstlisting}[language=bash]
generator$ ./generator.bin ../db start 0x100000001 segments 3
szegmens kezdet: 4 294 967 297
szegmensek száma: 3
kis szegmensek mérete: 22
elágazások bitjei: 8
felkészülés 1/4
felkészülés 2/4
felkészülés 3/4
felkészülés 4/4
felkészülés vége
szegmens 4 - kezdet 4 294 967 297 - felkészülés 8 162 031 487 ns - szitálás 729 914 370 ns
szegmens 5 - kezdet 5 368 709 121 - felkészülés           418 ns - szitálás 736 412 117 ns
szegmens 6 - kezdet 6 442 450 945 - felkészülés           385 ns - szitálás 750 022 409 ns
összes szitálás 2 216 348 896 ns

generator$ ./generator.bin ../db start 0x100000001 reserve-space 1000000000
szegmens kezdet: 4 294 967 297
fenntartandó hely: 1 000 000 000 byte 
kis szegmensek mérete: 22
elágazások bitjei: 8
felkészülés 1/4
felkészülés 2/4
felkészülés 3/4
felkészülés 4/4
felkészülés vége
szegmens 4 - kezdet 4 294 967 297 - felkészülés 8 162 031 487 ns - szitálás 729 914 370 ns
szegmens 5 - kezdet 5 368 709 121 - felkészülés           418 ns - szitálás 736 412 117 ns
szegmens 6 - kezdet 6 442 450 945 - felkészülés           385 ns - szitálás 750 022 409 ns
összes szitálás 2 216 348 896 ns
\end{lstlisting}
}

Mindkét program kimenetében a start a szegmens kezdőszáma, a segment az indexe,
$start=segment \cdot 2^{30}+1$, az init a szita incializálási ideje a szitálás előtt,
és a sieve a szegmens szitálásának ideje. Ezek az információk az elmentett
táblafájlokból is kiolvashatóak.

\section{Mintaadatbázis karbantartása}

A mintaadatbázis a lementett szitatáblák összesített statisztikáit tárolja.
A program az adatbázis könyvtárában kétfajta fájlt vesz figyelembe.  %%% EMLI: A MELYIK program?
A "primes\textbackslash.[0-9a-f]\{16\}" reguláris kifejezésnek megfelelő nevű  %%% EMIL: \fonttt{...} parancsot ismered?
fájlok a szegmensek szitatáblái.
A fájlnév második fele a szegmens kezdőszáma hexadecimálisan.
A fájl a páratlan számok bittérképe mellett tartalmazza a szegmens
szitálásának megkezdésére, és a szitálására fordított időt,
valamint ellenőrzésképpen a szegmens kezdőszámát is.

A szitatáblák mellett az adatbázis tartalmazhatja szegmensek összesített
statisztikáit is, "aggregates" néven. Ez a fájl az eddig összesített  %%% EMIL: LaTeX-ben a "helyett" ``ilyet'' szokás írni.  Az output sokkal szebb
szegmensről a kövekező információkat tartja nyilván:
\begin{itemize}
\item a szegmens kezdőszáma
\item a szegmens szitálására való felkészülés idejét
\item a szegmens szitálásának idejét
\item az összesítésre fordított időt
\item a szegmensfájl utolsó módosítási idejét
\item a szegmensbe eső legkisebb, és legnagyobb prímet
\item a szegmensbe eső prímek számát,
$12\mathbb{Z}11$, $4\mathbb{Z}1$, $4\mathbb{Z}3$, $6\mathbb{Z}1$ alakok szerinti bontásban %%% EMIL: Nem hiányoznak itt '+'-ok?
\item a szegmensben előforduló prímhézagok első előfordulásának helyét,
és az előfordulások számát.
\end{itemize}
%%% EMIL: Ide lehet jöhetne pár példa, hogy ez valójában hogy is néz ki.

Az adatbázison három művelet végezhető:
\begin{itemize}

\item Le lehet kérni, hogy eddig hány szegmens van összesítve,
és melyik a következő hiányzó szegmens.
Azt is visszaadja, hogy hány szegmensfájl van épp az adatbázis könyvtárában,
és hogy ezek között van-e olyan, ami nincs összesítve.  %%% EMIL: Mondat eleje, kicsit... kurta...

\item Összesíteni lehet az új szegmensfájlok.  %%% EMIL: ..at?

\item Össze lehet fésülni két összesítőfájlt.

\end{itemize}

Mindhárom művelet elvégezhető grafikus felületen, és automatizáláshoz parancssorból is.
A grafikus felületet a gui scripttel lehet indítani, a parancssorból
a database script segítségével lehet elérni a műveleteket.

Ezek a scriptek határozzák meg, hogy a program melyik könyvtárat használja
adatbázisként, ezt nem kell külön megadni.
Szükség esetén ez a könyvtár a scriptek egyszerű módosításával
megváltoztatható.

A szegmensinformációkat a grafikus felületen a "DB info" gomb megnyomásával lehet
lekérdezni, parancssorból a "database info" kiadásával.

{\tiny
\begin{lstlisting}[language=bash]
scripts$ ./database info
100.0%
szegmensfájlok: szegmensek száma: 7
szegmensfájlok: első szegmens kezdete: 1
szegmensfájlok: utolsó szegmens kezdete: 6,442,450,945
szegmensfájlok: első hiányzó szegmens kezdete: 7,516,192,769
szegmensfájlok: hiányzó szegmensek száma: 18,446,744,073,709,551,593

összesítések: szegmensek száma: 62,881
összesítések: első szegmens kezdete: 1
összesítések: utolsó szegmens kezdete: 67,516,885,893,121
összesítések: első hiányzó szegmens kezdete: 67,517,959,634,945
összesítések: hiányzó szegmensek száma: 18,446,744,073,709,488,719

új szegmensfájlok: 7

scripts$ ./database info crunch 100
100.0%
szegmensfájlok: szegmensek száma: 7
szegmensfájlok: első szegmens kezdete: 1
szegmensfájlok: utolsó szegmens kezdete: 6,442,450,945
szegmensfájlok: első hiányzó szegmens kezdete: 7,516,192,769
szegmensfájlok: hiányzó szegmensek száma: 18,446,744,073,709,551,593

összesítések: szegmensek száma: 62,881
összesítések: első szegmens kezdete: 1
összesítések: utolsó szegmens kezdete: 67,516,885,893,121
összesítések: első hiányzó szegmens kezdete: 67,517,959,634,945
összesítések: hiányzó szegmensek száma: 18,446,744,073,709,488,719

crunch: ../generator/generator.bin ../db start 0x3d6840000001 segments 0x64
\end{lstlisting}
}

A "crunch" utótag és szitálni kívánt szegmensek számának megadásával az utolsó sorban
a következő futtatásra ajánlott parancsot is megjeleníti a program.
Ezeknek a parancsoknak a követésével a teljes szitálható tartományt fel lehetne dolgozni.
A "crunch-numbers" script ezt a feladatot kísérli meg elvégezni.

Az info megjeleníti az új szegmensfájlok számát is, azokat,
amikhez vagy nem tartozik összesített adat, vagy tartozik,
de az ott tárolt utolsó módosításnál újabb a szegmensfájl.
Ezeket a "DB összesítés" gomb megnyomásával,
vagy a "database reaggregate" paranccsal lehet összesíteni.

{\tiny
\begin{lstlisting}[language=bash]
scripts$ ./database reaggregate
100.0%
\end{lstlisting}
}

Lehetőség van egy másik adatbázisból statisztikák átvételére is.
Az összefésülést a grafikus felületen a "DB import" megnyomása után
egy file kiválasztásával lehet indítani, parancssorból a "dabatase import aggregates fájlnév"
kiadásával. A megadott fájlból azokat a szegmeneseket veszi át a program,
amik vagy nincsenek még meg az adatbázisban, vagy megvannak, de az importált
statisztikák utolsó módosítási ideje nagyobb az adatbázisban lévőnél.

{\tiny
\begin{lstlisting}[language=bash]
scripts$ ./database import aggregates ../db/aggregates.large
100.0%
\end{lstlisting}
}

{\color{red}screenshot}
%%% EMIL: ezt a részt kicst kuszának tartom. Én személy szerint, lehet úgy csinálnam, pl (feltéve hogy már rendesen bevezetted a generátor, init, stb programokat), és akkor először felsorolnám a műveleteket, hogy egy-egy program milyen parancsokat tud, aztán meg külön külön leírnám azok működését. Valahogy "nem elég száraz" a szöveg, egymásba folynak a mondatok... és szerintem itt most épp egy kicsit szárazabb, szakmaibb leírás kellene.

\section{Szitatáblák ellenőrzése}

A generator program teszteléséhez a grafikus program képes a szegmensfájlok
ellenőrzésére.
Ehhez a program újra előállítja az ellenőrzött szegmensfájlokat,
és azokat összeveti. A újraelőállításhoz egy egyszerű szegmentált
Eratoszthenészi szitát, vagy ez erős pszeudo-prím tesztet lehet választani.
A pszeudo-prím teszt rendkívül lassú, a célja, hogy a szitákhoz képest egy
alapvetően más módszer is rendelkezésre álljon az ellenőrzéshez.

A grafikus felületen a "Szegmensfájlok ellenőrzése" gomb megnyomása után
lehet kiválasztani a szitálni kívánt szegmenseket, és a referencia előállításának
módszerét, majd az "Ellenőrzés" gombbal lehet megkezdeni a tényleges
folyamatot.

Az ellenőrzést parancssorból is lehet futtatni a check-segments scripttel.
A script első paraméterében a referencia módszerét várja,
ami lehet "sieve", vagy "test", a paraméterek maradéka az ellenőrizendő
szegmensek kezdőszáma kell legyen. Ha egy kezdet sincs megadva, akkor
a program az adatbázis könyvtárban található összes szegmensfájlt ellenőrzi.

{\tiny
\begin{lstlisting}[language=bash]
scripts$ ./check-segments sieve
100.0%: A szegmensek helyesek.             

scripts$ ./check-segments sieve 0x1 0xc0000001
100.0%: A szegmensek helyesek.             

scripts$ ./check-segments test 0x1
100.0%: A szegmensek helyesek.             

\end{lstlisting}
}

Ha a kezdőszám nagyobb, mint $1$, a szitával ellenőrzéshez szükséges,
hogy az init program által előállított négy darab szegmensfájlt tartalmazza
az adatbáziskönyvtár, mert a szita kezdőszámra pozícionálásához a prímszámokat
innen olvassa fel a program.

{\color{red}screenshot}

\section{Sziták ellenőrzése}

Az sebességek összehasonlításához írt sziták eredményét is lehet ellenőrizni,
az összehasonlításhoz itt is a szegmensek ellenőrzésénél használt
egyszerű szegmentált szita a referencia.

A program grafikus felületén a "Sziták ellenőrzése" lehetőséget
választva ki kell választani az ellenőrizendő szitát, és az ellenőrizni
kívánt intervallum kezdő és végző számát.
A folyamat az "Ellenőrzés" gomb megnyomásával indítható.

Parancssorból is ellenőrizhetőek a sziták a "check-sieve" scripttel.
A script 3 paramétere a szita neve, és az intervallum kezdő-, és végszáma.
Az ellenőrizhető sziták nevei:

\begin{itemize}
\item atkin: Atkin szitája
  %%% EMIL: Ezeket amikor először említed akkor \cite{} paranccsal hivatkozz rájuk https://www.overleaf.com/learn/latex/Bibliography_management_with_bibtex
\item cols: Cache optimized linear sieve
\item eratosthenes-segmented: Eratoszthenész szitájának szegmentált változata
\item bin-heap és bin-heap-inplace: Eratoszthenész szitája bináris kupaccal,
	az bin-heap-inplace a kupac javítását helyben végzi
\item buckets, buckets-n, buckets-simple: Eratoszthenész szitája edényekkel,
	a buckets-simple nem szegmentált, a buckets, és a buckets-n szegmentált.
	a buckets-n -ben az n helyére 1-től 8-ig a számrendszer bitjeit lehet megadni,
	pl. buckets-3 8as számrendszerben számol
\item trial-division: próbaosztás
\end{itemize}
%%% EMIL: Ezeket a módszereket definiáltad? Akár mennyire triviális és jól ismertek is (mint pl. a SOE - sieve of eratosthenese) akkor is le kell írni mit csinál (és lehet hogy ezt pl a fejlesztői dokumentációban kell, és itt meg hivatkozni hogy "pontos leírást pásd itt és itt").

A sziták nevei listázhatóak a list-sieves scripttel, a describe-sieves script rövid leírást
is ad.

{\tiny
\begin{lstlisting}[language=bash]
scripts$ ./check-sieve buckets-3 3000000000001 3010000000001
100.0%: A szita helyes.
\end{lstlisting}
}

Ha a kezdőszám nagyobb, mint egy, az ellenőrzéshez ilyenkor is szükséges,
hogy a négy darab kezdő szegmensfájlt tartalmazza az adatbáziskönyvtár.

{\color{red}screenshot}

\section{Minta megjelenítése} %%% EMIL: a "minta" nem tudom a legjobb elnevezés-e, prímek eloszlásáról beszélünk, nem?  Esetleg a $\pi(x)$ függvényt is bevezethetnéd 

A program a grafikus felületén képes mintákat ábrázolni, a mintákat függvényekkel
közelíteni, és ezeket a függvényeket is ábrázolni, valamint kiszámolja a közelítések
négyzetes hibáját a mintához képest.

A grafikonábrázoló részt a gui-graph scripttel lehet indítani,
vagy a gui scripttel, majd a "Grafikon" gomb megnyomásával.

Az ablak bal oldalán jelennek meg a betöltött minták és közelítő függvények
grafikonjai. Minta és függvény hozzáadása után a grafikon megjelenített részét
a program úgy választja meg, hogy minden minta összes pontja ebbe a nézetbe essen.
A nézet a grafikon feletti gombokkal, vagy egérrel mozgatható, nagyítható, vagy
kicsinyíthető.
Az "Auto.nézet" gombbal a nézet a minták teljes terjedelmére visszaállítható.

Az ablak jobb oldala a betöltött minták kezelésére szolgál.
A felső harmada az összes betöltött mintát mutatja.
Az ablak jobb oldalának alsó két harmadában az itt kiválaszott minta részletei
látszódnak.

\subsection{Minta hozzáadása}  %%% EMIL: Ez itt "hozzáadása" nem inkább beolvasása... betöltése... hmm... nem tom.

A "Minta hozzáadásánál" három adatforrásból lehet választani.
A "Fájl betöltésével" CSV fájl olvasható be. A fájl formátuma megengedő,
az első oszlopot x, a második oszlopot y értékeknek próbálja értelmezni,
a fel nem ismert sorokat eldobja. Ha az első sor első oszlopa "BARS",
akkor vonaldiagram helyett a mintát oszlopdiagramként fogja ábrázolni.

A "Prímstatisztiák" a generator kimeneteléből összesített statisztikák,
amiket az adatbáziskönyvtárban keres.
A program a szegmensstatisztikák hiánytalan kezdőszeletét veszi csak figyelembe.
A statisztikáknak négy csoportja van. A prímek száma, és néhány kiemelt alakú prím száma
a szegmensek végén. Ide tartozik ugyanezeken a helyeken a prímszámtétel
becslése, és a becslés abszolút és relatív hibája is.
Az ikerprímek száma a szegmensek végén.
A prímhézagok statisztikái a szegmensek teljes kezdőszeletére vonatkozik. Ezek
az előfordult hézagok gyakorisága, első előfordulása, jósága, és az legnagyobb
prímhézag adott számig.
Ezeken kívül a szegmensek szitálásának ideje is betölthető. Az összesített
idő a szegmensek végig az összes addigi szegmens összes ideje,
a szegmensenkénti a szegmensek végéhez az adott szegmens szitálásának idejét rendeli.

A minták harmadik forrása a programba épített sziták futási idejének mérése.
Ehhez meg kell adni a szitát, a szitált intervallum elejét és végét,
a szita belső szegmensméretét, a generálandó minták számát, és a mérések számát,
a mértéket, és hogy az eredményt összesítse-e.
A sziták listája ugyanaz, mint a sziták ellenőrzősénél.
A mintákat a program a szitált intervallumon egyenletesen osztja el a megadott méretű
szegmensek határainál. A teljes szitálást a megadott mérések számászor végzi el,
és az eredményt átlagolja.
Összesítést kiválasztva a minta értéke a szitált intervallum elejétől
az adott számig szitálás teljes ideje, különben az előző minta helyétől.
A mérték szabályozza, hogy a tényleges eltelt időt mérje a program nanoszekundumban,
vagy az elvégzett műveletek számát.

{\color{red}screenshot}

\subsection{Minta közelítése}

Az ablak jobb oldalának középső harmadában a kiválasztott minta részletei látszódnak.
Itt változtatható meg a minta ábrázolásához használt szín, távolítható el a minta,
vagy menthető CSV fájlba.

A táblázat a minta közelítéseit mutatja,
itt olvashatóak le a közelítés komponensfüggvényei, és a közelítés hibája.
A "Közelítés" gombbal lehet új közelítést hozzáadni az ábrázoláshoz.
A közelítéshez a lineáris legkisebb négyzetek módszerét használja a program,
ehhez a lineáris kombináció elemi függvényeit meg kell adni.
A függvények kiválaszthatóak az előre megadott listából,
vagy javascript nyelven is megadhatóak.
A közelítéshez csak olyan függvények használhatóak, amik a minta
minden pontjában értélmezve vannak.

Javascript függvényhez meg kell adni a függvény nevét és forráskódját.
A forráskódban a függvény argumentumára az $x$ változóval lehet hivatkozni,
és a script utolsó kifejezésének értéke lesz a függvény
értéke $x$-ben. Pl. az $x \mapsto \frac{\ln{x}}{x}$ hozzárendelés
forráskódja:

{\small
\begin{lstlisting}[language=Java]
Math.log(x)/x
\end{lstlisting}
}

A scriptben használható változó, és a szokásos vezérlőutasítások.
Pl. az iterált logaritmus egy megadása:
{\small
\begin{lstlisting}[language=Java]
var y=0;
while (1<x) {
  x=Math.log(x);
  ++y;
}
y
\end{lstlisting}
}

Az így megadott függvények visszatérési értéke mindig double kell legyen,
és a függvény azokban a pontokban értelmezett, ahol ez az érték véges.

Egy kiválasztott közelítés részletei az ablak jobb alsó sarkában látszódnak,
itt megváltoztatható a közelítéshez rendelt szín, és eltávolítható a közelítés.
A táblázat a közelítéshez kiválasztott függvények együtthatóit mutatja
a lineáris kombinációban.
%%% EMIL: Ezeket egy kicsit matekossan is leírhatod... megadod az f1 f2 függvényeket és a program megkeresi a lambda1 lambda2 skalárokat...

{\color{red}screenshot}

\section{Sziták mérése scriptekkel}

%%% EMLI: Ez nem inkonzisztens? Eddi úgy volt hogy egy szekcióban egy funkció (csoportot) írtál le, és ott volt a GUI és CLI végrehajtás is, nem így külön szekcióban, nem? (és hogy a francba mondják magyarul a "sectiont"?)
A sziták futási idejének mintáit parancssorból is elő lehet állítani
a measure-sieve scripttel, paraméterként meg kell adni ebben a sorrendben:

\begin{itemize}
\item a szita nevét, ezek ugyan azok lehetnek, mint a check-sieve scriptnél
\item a számot, ahol a szitálás kezdedődik, ez páratlan szám kell legyen
\item a szitálás végét, ez páratlan szám kell legyen
\item a szegmensek méretét
\item a mérések számát
\item a minták számát
\item hogy időt (nanosecs), vagy műveleteket (operations) mérjen
\item összesítse az időket ("sum"), vagy szegmensenként külön számolja ("segment")
\item a fájlt, ahova az eredményt mentse CSV-ben
\end{itemize}

A számokat meg lehet adni decimálisan, és hexadecimálisan is "0x" előtaggal.
Ha a kezdőszám nagyobb, mint 1, akkor az adatbáziskönyvtárnak tartalmaznia
kell az init program generálta első négy szegmenst.

Lehetőség van a mérték és az összesítés mind a négy kombinációját egy
méréssel előállítani, ehhez mind a négy kimeneti fájl meg kell adni külön.

{\tiny
\begin{lstlisting}[language=bash]
scripts$ ./measure-sieve buckets-3 1 0x10000001 0x10000 3 1000 nanosecs sum out1.csv
100.0%
scripts$ ./measure-sieve buckets-3 1 0x10000001 0x10000 3 1000 operations segment out2.csv
100.0%
scripts$ ./measure-sieve buckets-3 1 0x10000001 0x10000 3 1000
seg-ns.csv seg-ops.csv sum-ns.csv sum-ops.csv
100.0%
\end{lstlisting}
}

A mérések megkönnyítéséhez a measure-sieves script az összes szitát megméri,
és az eredményt a samples könyvtárba menti.

{\color{red}teljes. generator. atkin szegmens méret.}

\chapter{Fejlesztői dokumentáció}

\section{A feladat leírása}

A program fő feladata, hogy lehetővé tegye prímsziták futási idejének összehasonlítását.
Ehhez keretet kell adjon, hogy azonos paraméterekkel lehessen a sziták futási idejét mérni,
és egyszerű, egymáshoz hasonlóan optimalizált szitákat kell implementálni,
hogy a futási időket a fő algoritmusok határozzák meg, mivel a szitálást felgyorsító
egyes ötletek nem minden szitán alkalmazhatóak.
Elvárás, hogy a futási időt eltelt időben, és összeszámolt műveletekben is lehessen mérni.

A szitákat szegmentáltan kell megvalósítani, és szabályozhatóvá kell tenni
a szegmensek méretét, és a szitálás kezdő és végszegmensét. A megvalósítandó sziták:
\begin{itemize}
\item Atkin szitája
\item Eratoszthenész szitája
\begin{itemize}
\item egyszerű tömbbel
\item bináris kupaccal
\item edényekkel
\item edények monoton sorával
\end{itemize}
\end{itemize}

A programnak grafikusan ábrázolnia kell a futási időket, és lehetőséget kell adjon
ezek közelítésére függvényekkel. A közelítéshez a legkisebb négyzetek módszerét
kell használni, és az elemi függvények legyenek megválaszthatóak.
Elemi függvényt lehessen megadni JavaScript nyelven is.

A grafikus ábrázolás legyen képes külső forrásokból származó minták megjelenítésére
és közelítésére is. A prímszámok néhány statisztikájának megjelenítéséhez elő kell tudni
állítani ezeket a statisztikákat nagyobb intervallumokon is.
Ehhez adni kell egy szitát, ami hatékonyan képes $2^{64}$-ig szitálni,
és ennek az eredményét összesíteni kell. Az előállítható statisztikák
adott $n$-ig szitálva legyenek:
\begin{itemize}
\item a prímek száma
\item a $4\mathbb{Z}+1, 4\mathbb{Z}+3, 6\mathbb{Z}+1, 12\mathbb{Z}+11$
	alakú prímek száma
\item az ikerprímek száma
\item az előforduló prímhézagok első előfordulásának helye
\item a prímhézagok előfordulásának száma
\item a szitálásra fordított idő
\end{itemize}

A prímek számát, az ikerprímek számát, és a szitálás idejét
nem csak a szitált intervallum végén
kell előállítani, hanem az intervallum belsejében is több ponton.

A sziták sebességének mérését, és a statisztikák előállítását
parancssorból is el kell tudni végezni, hogy szkriptekkel ez automatizálható legyen.
A statisztikák előállításánál ezen túl még elvárás, hogy a folyamat leállítható,
és később folytatható legyen.

\section{A program komponensei}

\section{A forráskód felosztása}

\section{Adatszerkezetek}

\section{Numerikus algoritmusok}

Egyenletrendszerek. Összeadás.
Körül kéne írni, hogy igazán tudjuk, hogy hipotézisvizsgálatra nem vállalkozunk.
A grafikonrajzolónak sokkal okosabbnak kéne lennie, hogy gyorsan változó függvényeket
helyesen jelenítsen meg, reménytelenül okosnak.

\section{Sziták}

Eratosztenész szitája, szegmentáltan is. COLS. Prioritásos sorral. Atkin szitája.

Szegmentált szita inicializálása.

Trial division. Pszeudoprím teszt.

Feltételek. Elméleti sebesség.

\section{Prioritásos sorok}

\begin{algorithmic}[1]
\State $q \gets$ \Call{Új-sor}{}
\For{$i\gets 2, n$}
	\While{$\exists (p, k) \in q: k \le i$}
		\State $(p, k) \gets $ \Call{Sor-Eltávolít-Min}{q}
		\State \Call{Megjelöl}{i}
		\State \Call{Sor-Beszúr}{q, (p, k+p)}
	\EndWhile
	\If{$\neg$ \Call{Megjelölt?}{i}}
		\State \Call{Sor-Beszúr}{q, (i, 2i)}
	\EndIf
\EndFor
\end{algorithmic}

\subsection{Bináris kupac}

A mérések grafikonják pixelei alapján lassú. A beszúrásonkénti elméleti
$\mathcal{O}(log_{}{|q|})$ ideje se biztató.

\subsection{Bigyó}

A bigyó egy monoton prioritásos sor.
A sor monoton, minden állapotához tartozik egy érték, a sor aktuális pozíciója,
aminél kisebb vagy egyenlő pozíciójú értéket a sor nem tartalmazhat.
A bigyó edények egy végtelen sorozatát is tárolja, a sor elemei ezekbe az edényekbe kerülnek.
Egy eltárolt elem helyét a sorozatban az elem pozíciójának
és a sor aktuális pozíciójának távolsága határozza meg.

A távolságfüggvény legyen

\begin{align*}
d(x, y) := \lfloor log_{2}{}(x \oplus y) \rfloor & & (x, y \in \mathbb{N}, y > x \ge 0)
\end{align*}

ahol $\oplus$ a bitenkénti XOR.

$d(x, y)$ a legnagyobb bit-index, ahol $x$ és $y$ eltér.

Ha $q$ egy bigyó, legyen $q.a$ $q$ aktuális pozíciója, és $q.e[i]$ $q$ $i$. edénye. AZ edények, és a számpárok struktúrája...

Egy q bigyó invariánsa
\begin{align*}
\forall (p, k) \in q &: &\\ 
	& q.a < k\\
	& \forall i \in \mathbb{N}_{0}: (p, k) \in q.e[i] \iff i=d(q.a, k) \\
\forall (p, k) \not\in q &: \forall i \in \mathbb{N}_{0}: (p, k) \not\in q.e[i]
\end{align*}

Új, üres sor létrehozása tetszőleges kezdőpozíciótól, és meglévő sorba elem beszúrása...

A sor elemeinek feldolgozása $i$-ig
\begin{algorithmic}[1]
\While{$q.a < i$}
	\State $j \gets d(q.a, q.a + 1)$
	\State $q.a \gets q.a + 1$
	\ForAll{$(p, k) \in q.e[j]$}
		\State \Call{Edény-Kivesz}{$q.e[j], (p, k)$}
		\If{$k = i$}
			\State \Call{Visszaad}{$(p, k)$}
		\Else
			\State \Call{Edény-Beszúr}{$d(q.a, k), (p, k)$}
		\EndIf
	\EndFor
\EndWhile
\end{algorithmic}

\subsubsection{Helyesség}

\subsubsection{Idő}

\subsubsection{Hely}

\subsubsection{Számrendszer}

És számrendszer vs. tisztán funkcionálisban nincs bármekkora tömb, csak valami fával közelítve.

Amúgy sincs bármekkora tömb...

És exponenciálisan kell növelni...

\subsubsection{Cache}

És exponenciálisan kell növelni...

\section{Memória}

Összes prím, és pozíciója $2^32$-ig. Primitív típusok és boxing. Garbage collector.

\section{Teszt}

\subsection{Adatszerkezetek}

\subsection{Numerikus pontosság és sebesség}

\subsection{Sziták}

\subsection{Elmélet vs. mért}

\section{Források}

\end{document}

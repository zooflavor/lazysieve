\documentclass[12pt]{report}
\usepackage[a4paper,
			inner = 35mm,
			outer = 25mm,
			top = 25mm,
			bottom = 25mm]{geometry}
\usepackage{lmodern}
\usepackage[magyar]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[unicode]{hyperref}
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{epstopdf}
\usepackage{setspace}
\usepackage[nottoc,numbib]{tocbibind}
\usepackage{color}
\setcounter{secnumdepth}{3}
\usepackage{algpseudocode}
\usepackage{listings}
\usepackage{titlesec}
\onehalfspacing
\begin{document}
\begin{titlepage}
\vspace*{0cm}
\centering
\begin{tabular}{cp{2cm}c}
\begin{minipage}{4cm}
\vspace{0pt}
\includegraphics[width=1\textwidth]{eltecimerszines}
\end{minipage} & &
\begin{minipage}{7cm}
\vspace{0pt}Eötvös Loránd Tudományegyetem \vspace{10pt} \newline
Informatikai Kar \vspace{10pt} \newline
Komputeralgebra Tanszék
\end{minipage}
\end{tabular}

\vspace*{0.2cm}
\rule{\textwidth}{1pt}

\vspace*{6cm}
{\Huge Prímszita algoritmusok összehasonlítása}

\vspace*{5cm}
\begin{tabular}{lp{3cm}l}
Vatai Emil & & Nagy Péter\\
Adjunktus & & Programtervező Informatikus BSc
\end{tabular}

\vfill

\vspace*{1cm}
Budapest, 2018
\end{titlepage}

\tableofcontents

\chapter{Bevezetés}

Sziták összehasonlítása azonos környezetben.
Hatékonyság összehasonlítása az elmélet szerint várható értékekkel.
Ellenőrzésként a prímek néhány statisztikájának összevetése az elméleti értékekkel,
és az ismert eredményekkel.
Hatékonyság és implementálhatóság.

\chapter{Felhasználói dokumentáció}

\section{A megoldott feladat}

A program lehetővé teszi különböző sziták futási idejének ábrázolását grafikonon,
és összevetését elméleti becsült értékekkel.
A programmal egyéb forrásból származó minták megjelenítése is lehetséges.

A prímszámok statisztikáinak előállításához a programhoz tartozik egy optimalizát
szita-implementáció, amivel $2^{64}$-ig lehet szitálni, és az eredményt rögzíteni.
Az elmentett eredményeket a program egy külön része összesíti néhány alapstatisztikára.

Különböző szita-algoritmusok futási idejének összehasonlításához a program tartalmazza
Atkin szitájának egy implementációját, és Eratosztenész szitájának néhány variációját.

\section{Felhasznált módszerek}

A program két rész fő részből áll.
A prímszámok generátora C-99 nyelven készült el.
A program csak parancssorból futtatható, és a sztenderd könvytári függvényekből
is csak néhányat használ a memóriájában előállítótt eredmények fájlba írásához.
A C nyelv választását a hatékony végrehajtás és memórafelhasználás, és
a hordozhatóság indokolja, a generátor elkülönítését az automatizálhatóság indokolja.

A prímgenerátor Eratosztenész szitájának szegmentált változata,
a szitatábla egy $2^{30}$ hosszú darabját szitálja ki minden iterációban.
A generátor önmaga is két részből áll.
Egy egyszerűbb implementáció a prímek listáját állítja elő $2^{32}$-ig.

A gyorsabb, de összetettebb szita $2^{32}$-től $2^{64}-2^{34}$-ig szitál,
és a futásához szükséges a prímek listája $2^{32}$-ig.
A szitatáblát a memóriában a gyorsítótár hatékonyabb a kihasználásához kisebb
résszegemensekre osztja,
és a prímeket a nagyságuk és a következő szitálási pozíciójuk szerint csoportosítja.
Továbbá nagyobb prímeknek csak harminccal relatív prím többszöröseit veszi figyelembe.

A program többi része a Java környezethez készült, a képzésben betöltött szerepe és
a hordozhatósága miatt.
A minták és függvények ábrázolásához használt Swing grafikus könyvtár
a Java környezet része, egyszerű, hordozható, támogatja az élsimítást,
és a sebessége elfogadható a feladatra.
A Java sztenderd konténerosztájai habár kényelmesen használhatóak, és változatosak,
de sebesség és memóriakihasználtsági problémák miatt több helyen is alacsonyabb szintű
megoldást kellett választani.

A program a mintákat alapfüggvények lineáris kombinációjával képes közelíteni,
a legkisebb négyzetek módszerével. A minták elemeinek nagy száma, és a mintaértékek
nagy terjedelme miatt szükséges volt a numerikus algoritmusok nagyobb pontosságú
implementációja, ami a számítási idő növekedésével jár.

A program hosszabb távon egyedül a prímek szegmensenkénti statisztikáit tárolja,
amit csak sorban dolgoz fel, és a statisztikák összmérete sem indokolna
egy egyszerű bináris fájlnál bonyolultabb megoldást. Az adatvesztés elkerüléséhez
elég a statiszikafájl csere alapú felülírása.

A Java program tartalmaz több prímszita implementációt is, ezeknek az algoritmikus
bonyolultsága különböző, de az összehasonlíthatósághoz a közös részek közös
implementációt kaptak, és az eltérő részek hasonló szinten optimalizáltak.
A sziták helyességének ellenőrzéséhez a sziták eredménye egymással összehasonlítható.
A programhoz elkészült Atkin szitája, és Eratoszthenész szitájának több variációja:
az algoritmus legegyszerűbb implementációja a teljes szitatáblán jelöli meg
a prímek többszöröseit, a többi a táblát rövidebb szegmensekre osztja fel,
és ezeket sorban szitálja. A szegmentálás szükségessé teszi, hogy eldüntsük,
hogy mely szegmensben mely prímek szitálnak. A legegyszerűbb megvalósítás
minden szegmensben minden prímmel megpróbál szitálni, a próbaosztáshoz hasonlóan.
Ennél hatékonyabb a két elsőbbségi sorral megvalósított szita, és a harmadik,
edényekbe csoportosító megoldás.

A sziták között kapott helyet a próbaosztás, és az erős pszeudo-prím teszt is,
de ezek a lassúságuk miatt csak igen rövid tartományok ellenőrzésére alkalmasak.

\section{A program telepítése és futtatása}

A Java program futtatásához JRE8-ra van szükség,
a fordításához JDK8-ra. A C program fordításához C99
szabványú fordítóprogram kell. A program fejlesztése
és tesztelése OpenJDK8-cal és GCC 7.3-mal történt
Linux operációs rendszeren.

A tarball a Java programot lefordítva is tartalmazza,
kicsomagolás után azonnal futtatható.
A C programot a generator könyvtárban található Makefile segítségével lehet lefordítani:
\begin{lstlisting}[language=bash]
generator$ make clean build
\end{lstlisting}

A Java program a NetBeans 8-as verziójával készült,
parancssorból a project ant fájlának segítségével lehet
újrafordítani:
\begin{lstlisting}[language=bash]
gui$ ant clean jar
\end{lstlisting}

A program futtatásához több előkészített script is rendelkezésre áll,
ezeket mind a scripts könyvtárból lehet indítani.
Az előző két fordítást egyben is el lehet végezni a recompile scripttel:
\begin{lstlisting}[language=bash]
scripts$ ./recompile
\end{lstlisting}

\section{Prímek keresése}

A prímek keresését két program végzi, az init program
$2^{32}$-ig keresi meg és tárolja el a prímeket,
a generator $2^{32}$-től $2^{64}-2^{43}$-ig.
Az init készítette szitattáblák a generator futásához szükségesek.

Mindkét program a számokat $2^{30}$ hosszú táblánkként szitálja,
minden tábla első száma $2^{30}k+1$ alakú. A szitatáblákat a programok a
fájlrendszerben bittérképként tárolják, egy tábla kb. $64$Mb.

Az első négymilliárd szám szitálása a következő képpen indítható el:

\tiny
\begin{lstlisting}[language=bash]
generator$ ./init.bin ../db
segment 0 - start             1 - init 152 512 370 ns - sieve 1 068 908 595 ns
segment 1 - start 1 073 741 825 - init   2 095 563 ns - sieve 1 117 359 702 ns
segment 2 - start 2 147 483 649 - init   2 107 942 ns - sieve 1 127 848 722 ns
segment 3 - start 3 221 225 473 - init   1 996 728 ns - sieve 1 145 187 514 ns
\end{lstlisting}
\small

Ennek eredmény 4 bittérképfájl, amit a db mappába ment.

A generator programot több féle képpen is lehet indítani.
Mindegyik esetben két paramétert kell megadni az indításhoz,
a számot, ahol szitálást kezdje, és a szegmensek számát, amit
ebben a futásban végig kell szitálni.
A kezdő számot meg lehet adni decimálisan is, vagy hexadecimálisan is,
"0x" prefixszel. A szegmensek számát is kétféle képpen lehet szabályozni.
Az egyik lehetőség fix számú szegmens megadása, decimálisan.
A másik mód a háttértáron fenntartandó szabad hely átadása, decimálisan,
vagy "0x" prefixszel hexadecimálisan.

\tiny
\begin{lstlisting}[language=bash]
generator$ ./generator.bin ../db start 0x100000001 segments 3
segment start: 4 294 967 297
segment count:             3
small segment size: 22
bucket bits: 8
init segment 0
init segment 1
init segment 2
init segment 3
init end
segment 4 - start 4 294 967 297 - init 7 812 301 909 ns - sieve 704 592 094 ns
segment 5 - start 5 368 709 121 - init           340 ns - sieve 707 145 420 ns
segment 6 - start 6 442 450 945 - init           371 ns - sieve 715 291 366 ns
all sieve nanos 2 127 028 880 ns
\end{lstlisting}
\small

\tiny
\begin{lstlisting}[language=bash]
generator$ ./generator.bin ../db start 0x100000001 reserve-space 1000000000
segment start:    4 294 967 297
space to reserve: 1 000 000 000
small segment size: 22
bucket bits: 8
init segment 0
init segment 1
init segment 2
init segment 3
init end
segment 4 - start 4 294 967 297 - init 7 834 902 368 ns - sieve 693 775 928 ns
segment 5 - start 5 368 709 121 - init         1 018 ns - sieve 705 013 333 ns
segment 6 - start 6 442 450 945 - init        16 917 ns - sieve 705 195 144 ns
\end{lstlisting}
\small

Mindkét program kimenetében a start a szegmens kezdőszáma, a segment az indexe,
$start=segment \cdot 2^{30}+1$, az init a szita incializálási ideje a szitálás előtt,
és a sieve a szegmens szitálásának ideje. Ezek az információk az elmentett
táblafájlokból is kiolvashatóak.

\section{Mintaadatbázis karbantartása}

A mintaadatbázis a lementett szitatáblák összesített statisztikáit tárolja.
A program az adatbázis könyvtárában kétfajta fájlt vesz figyelembe.
A "primes\textbackslash.[0-9a-f]\{16\}" reguláris kifejezésnek megfelelő nevű
fájlok a szegmensek szitatáblái.
A fájlnév második fele a szegmens kezdőszáma hexadecimálisan.
A fájl a páratlan számok bittérképe mellett tartalmazza a szegmens
szitálásának megkezdésére, és a szitálására fordított időt,
valamint ellenőrzésképpen a szegmens kezdőszámát is.

A szitatáblák mellett az adatbázis tartalmazhatja szegmensek összesített
statisztikáit is, "aggregates" néven. Ez a fájl az eddig összesített
szegmensről a kövekező információkat tartja nyilván:
\begin{itemize}
\item a szegmens kezdőszáma
\item a szegmens szitálására való felkészülés idejét
\item a szegmens szitálásának idejét
\item az összesítésre fordított időt
\item a szegmensfájl utolsó módosítási idejét
\item a szegmensbe eső legkisebb, és legnagyobb prímet
\item a szegmensbe eső prímek számát,
$12\mathbb{Z}11$, $4\mathbb{Z}1$, $4\mathbb{Z}3$, $6\mathbb{Z}1$ alakok szerinti bontásban
\item a szegmensben előforduló prímhézagok első előfordulásának helyét,
és az előfordulások számát.
\end{itemize}

Az adatbázison három művelet végezhető:
\begin{itemize}

\item Le lehet kérni, hogy eddig hány szegmens van összesítve,
és melyik a következő hiányzó szegmens.
Azt is visszaadja, hogy hány szegmensfájl van épp az adatbázis könyvtárában,
és hogy ezek között van-e olyan, ami nincs összesítve.

\item Összesíteni lehet az új szegmensfájlok.

\item Össze lehet fésülni két összesítőfájlt.

\end{itemize}

Mindhárom művelet elvégezhető grafikus felületen, és automatizáláshoz parancssorból is.
A grafikus felületet a gui scripttel lehet indítani, a parancssorból
a database script segítségével lehet elérni a műveleteket.

Ezek a scriptek határozzák meg, hogy a program melyik könyvtárat használja
adatbázisként, ezt nem kell külön megadni.
Szükség esetén ez a könyvtár a scriptek egyszerű módosításával
megváltoztatható.

A szegmensinformációkat a grafikus felületen a "DB info" gomb megnyomásával lehet
lekérdezni, parancssorból a "database info" kiadásával.

\tiny
\begin{lstlisting}[language=bash]
scripts$ ./database info
100%
segment files: number of segments: 4
segment files: start of the first segment: 1
segment files: start of the last segment: 3,221,225,473
segment files: start of the first missing segment: 4,294,967,297
segment files: number of missing segments: 18,446,744,073,709,551,596
aggregates: number of segments: 4
aggregates: start of the first segment: 1
aggregates: start of the last segment: 3,221,225,473
aggregates: start of the first missing segment: 4,294,967,297
aggregates: number of missing segments: 18,446,744,073,709,551,596
new segment files: 4

scripts$ ./database info crunch 100
100%
segment files: number of segments: 4
segment files: start of the first segment: 1
segment files: start of the last segment: 3,221,225,473
segment files: start of the first missing segment: 4,294,967,297
segment files: number of missing segments: 18,446,744,073,709,551,596
aggregates: number of segments: 4
aggregates: start of the first segment: 1
aggregates: start of the last segment: 3,221,225,473
aggregates: start of the first missing segment: 4,294,967,297
aggregates: number of missing segments: 18,446,744,073,709,551,596
crunch: ../generator/generator.bin ../db start 0x100000001 segments 0x64
\end{lstlisting}
\small

A "crunch" utótag és szitálni kívánt szegmensek számának megadásával az utolsó sorban
a következő futtatásra ajánlott parancsot is megjeleníti a program.
Ezeknek a parancsoknak a követésével a teljes szitálható tartományt fel lehetne dolgozni.
A "crunch-numbers" script ezt a feladatot kísérli meg elvégezni.

Az info megjeleníti az új szegmensfájlok számát is, azokat,
amikhez vagy nem tartozik összesített adat, vagy tartozik,
de az ott tárolt utolsó módosításnál újabb a szegmensfájl.
Ezeket a "DB reaggregate" gomb megnyomásával,
vagy a "database reaggregate" paranccsal lehet összesíteni.

\tiny
\begin{lstlisting}[language=bash]
scripts$ ./database reaggregate
100%
\end{lstlisting}
\small

Lehetőség van egy másik adatbázisból statisztikák átvételére is.
Az összefésülést a grafikus felületen a "DB import" megnyomása után
egy file kiválasztásával lehet indítani, parancssorból a "dabatase import aggregates fájlnév"
kiadásával. A megadott fájlból azokat a szegmeneseket veszi át a program,
amik vagy nincsenek még meg az adatbázisban, vagy megvannak, de az importált
statisztikák utolsó módosítási ideje nagyobb az adatbázisban lévőnél.

\tiny
\begin{lstlisting}[language=bash]
scripts$ ./database import aggregates ../db/aggregates.large
100%
\end{lstlisting}
\small

\section{Szitatáblák ellenőrzése}

\section{Minta megjelenítése}

\section{Minta közelítése függvényekkel}

\section{Minták generálása scriptekkel}

\section{Sziták ellenőrzése scriptekkel}


\chapter{Fejlesztői dokumentáció}

\section{A feladat leírása}

\section{A program komponensei}

\section{A forráskód felosztása}

\section{Adatszerkezetek}

\section{Numerikus algoritmusok}

Egyenletrendszerek. Összeadás.
Körül kéne írni, hogy igazán tudjuk, hogy hipotézisvizsgálatra nem vállalkozunk.

\section{Sziták}

Eratosztenész szitája, szegmentáltan is. COLS. Prioritásos sorral. Atkin szitája.

Szegmentált szita inicializálása.

Trial division. Pszeudoprím teszt.

Feltételek. Elméleti sebesség.

\section{Prioritásos sorok}

\begin{algorithmic}[1]
\State $q \gets$ \Call{Új-sor}{}
\For{$i\gets 2, n$}
	\While{$\exists (p, k) \in q: k \le i$}
		\State $(p, k) \gets $ \Call{Sor-Eltávolít-Min}{q}
		\State \Call{Megjelöl}{i}
		\State \Call{Sor-Beszúr}{q, (p, k+p)}
	\EndWhile
	\If{$\neg$ \Call{Megjelölt?}{i}}
		\State \Call{Sor-Beszúr}{q, (i, 2i)}
	\EndIf
\EndFor
\end{algorithmic}

\subsection{Bináris kupac}

A mérések grafikonják pixelei alapján lassú. A beszúrásonkénti elméleti
$\mathcal{O}(log_{}{|q|})$ ideje se biztató.

\subsection{Bigyó}

A bigyó egy monoton prioritásos sor.
A sor monoton, minden állapotához tartozik egy érték, a sor aktuális pozíciója,
aminél kisebb vagy egyenlő pozíciójú értéket a sor nem tartalmazhat.
A bigyó edények egy végtelen sorozatát is tárolja, a sor elemei ezekbe az edényekbe kerülnek.
Egy eltárolt elem helyét a sorozatban az elem pozíciójának
és a sor aktuális pozíciójának távolsága határozza meg.

A távolságfüggvény legyen

\begin{align*}
d(x, y) := \lfloor log_{2}{}(x \oplus y) \rfloor & & (x, y \in \mathbb{N}, y > x \ge 0)
\end{align*}

ahol $\oplus$ a bitenkénti XOR.

$d(x, y)$ a legnagyobb bit-index, ahol $x$ és $y$ eltér.

Ha $q$ egy bigyó, legyen $q.a$ $q$ aktuális pozíciója, és $q.e[i]$ $q$ $i$. edénye. AZ edények, és a számpárok struktúrája...

Egy q bigyó invariánsa
\begin{align*}
\forall (p, k) \in q &: &\\ 
	& q.a < k\\
	& \forall i \in \mathbb{N}_{0}: (p, k) \in q.e[i] \iff i=d(q.a, k) \\
\forall (p, k) \not\in q &: \forall i \in \mathbb{N}_{0}: (p, k) \not\in q.e[i]
\end{align*}

Új, üres sor létrehozása tetszőleges kezdőpozíciótól, és meglévő sorba elem beszúrása...

A sor elemeinek feldolgozása $i$-ig
\begin{algorithmic}[1]
\While{$q.a < i$}
	\State $j \gets d(q.a, q.a + 1)$
	\State $q.a \gets q.a + 1$
	\ForAll{$(p, k) \in q.e[j]$}
		\State \Call{Edény-Kivesz}{$q.e[j], (p, k)$}
		\If{$k = i$}
			\State \Call{Visszaad}{$(p, k)$}
		\Else
			\State \Call{Edény-Beszúr}{$d(q.a, k), (p, k)$}
		\EndIf
	\EndFor
\EndWhile
\end{algorithmic}

\subsubsection{Helyesség}

\subsubsection{Idő}

\subsubsection{Hely}

\subsubsection{Számrendszer}

És számrendszer vs. tisztán funkcionálisban nincs bármekkora tömb, csak valami fával közelítve.

Amúgy sincs bármekkora tömb...

És exponenciálisan kell növelni...

\subsubsection{Cache}

És exponenciálisan kell növelni...

\section{Memória}

Összes prím, és pozíciója $2^32$-ig. Primitív típusok és boxing. Garbage collector.

\section{Teszt}

\subsection{Adatszerkezetek}

\subsection{Numerikus pontosság és sebesség}

\subsection{Sziták}

\subsection{Elmélet vs. mért}

\section{Források}

\end{document}
